<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äººè„¸æ‰‹åŠ¨å½•å…¥ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .section h2 {
            color: #495057;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            align-items: center;
        }

        .section h2 .icon {
            margin-right: 10px;
            font-size: 1.2em;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .grid-three {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .grid, .grid-three {
                grid-template-columns: 1fr;
            }
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #212529;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #e83e8c 100%);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-success { background: #28a745; }
        .status-error { background: #dc3545; }
        .status-warning { background: #ffc107; }
        .status-info { background: #17a2b8; }

        .video-container {
            width: 100%;
            height: 350px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
        }

        .video-placeholder {
            color: #666;
            font-size: 1.2em;
            text-align: center;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .capture-area {
            position: relative;
            text-align: center;
        }

        .captured-image {
            max-width: 100%;
            max-height: 400px; /* å¢åŠ æœ€å¤§é«˜åº¦ï¼Œå‡å°‘è¿‡åº¦ç¼©æ”¾ */
            border: 2px solid #ddd;
            border-radius: 10px;
            margin: 10px 0;
            display: block;
            object-fit: contain; /* ç¡®ä¿å›¾åƒå®Œæ•´æ˜¾ç¤º */
            /* é¿å…å›¾åƒè¢«å‹ç¼©å˜å½¢ */
        }

        .face-detection-overlay {
            position: relative;
            display: block;
            text-align: center;
            /* é¿å…inline-blocké€ æˆçš„å®šä½é—®é¢˜ */
        }

        .face-box {
            position: absolute;
            border: 3px solid #28a745;
            background: rgba(40, 167, 69, 0.1);
            pointer-events: none;
        }

        .face-confidence {
            position: absolute;
            background: rgba(40, 167, 69, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            top: -25px;
            left: 0;
        }

        .log-area {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-info { color: #17a2b8; }
        .log-success { color: #28a745; }
        .log-warning { color: #ffc107; }
        .log-error { color: #dc3545; }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .alert {
            padding: 12px 16px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .alert-danger {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .step-indicator {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 0 20px;
        }

        .step {
            flex: 1;
            text-align: center;
            position: relative;
        }

        .step:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 15px;
            right: -50%;
            width: 100%;
            height: 2px;
            background: #e9ecef;
            z-index: -1;
        }

        .step.active:not(:last-child)::after {
            background: #667eea;
        }

        .step-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #e9ecef;
            color: #6c757d;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 8px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .step.active .step-circle {
            background: #667eea;
            color: white;
        }

        .step.completed .step-circle {
            background: #28a745;
            color: white;
        }

        .step-text {
            font-size: 12px;
            color: #6c757d;
            font-weight: 500;
        }

        .step.active .step-text {
            color: #667eea;
        }

        .step.completed .step-text {
            color: #28a745;
        }

        .registration-form {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }
        }

        .required {
            color: #dc3545;
        }

        .device-info {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .device-info h4 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .validation-error {
            color: #dc3545;
            font-size: 12px;
            margin-top: 5px;
            min-height: 16px;
        }

        .form-group input.error,
        .form-group select.error {
            border-color: #dc3545;
            box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);
        }

        .form-group input.valid,
        .form-group select.valid {
            border-color: #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ§‘â€ğŸ’¼ äººè„¸æ‰‹åŠ¨å½•å…¥ç³»ç»Ÿ</h1>
            <p>ç”¨äºäººè„¸é‡‡é›†å’Œäººå‘˜ä¿¡æ¯å½•å…¥çš„å®Œæ•´è§£å†³æ–¹æ¡ˆ</p>
        </div>

        <!-- è¿›åº¦æŒ‡ç¤ºå™¨ -->
        <div class="step-indicator">
            <div class="step active" id="step1">
                <div class="step-circle">1</div>
                <div class="step-text">æœåŠ¡å™¨é…ç½®</div>
            </div>
            <div class="step" id="step2">
                <div class="step-circle">2</div>
                <div class="step-text">è¿æ¥æ‘„åƒå¤´</div>
            </div>
            <div class="step" id="step3">
                <div class="step-circle">3</div>
                <div class="step-text">äººè„¸æ‹æ‘„</div>
            </div>
            <div class="step" id="step4">
                <div class="step-circle">4</div>
                <div class="step-text">ä¿¡æ¯å½•å…¥</div>
            </div>
            <div class="step" id="step5">
                <div class="step-circle">5</div>
                <div class="step-text">å®Œæˆå…¥åº“</div>
            </div>
        </div>

        <!-- æœåŠ¡å™¨é…ç½®åŒºåŸŸ -->
        <div class="section">
            <h2><span class="icon">âš™ï¸</span>æœåŠ¡å™¨é…ç½®</h2>
            <div class="grid">
                <div>
                    <div class="form-group">
                        <label for="signalingUrl">ä¿¡ä»¤æœåŠ¡å™¨åœ°å€:</label>
                        <input type="text" id="signalingUrl" value="ws://120.55.85.213:8081" placeholder="ws://æœåŠ¡å™¨IP:ç«¯å£">
                    </div>
                    <div class="form-group">
                        <label for="authUrl">è®¤è¯æœåŠ¡å™¨åœ°å€:</label>
                        <input type="text" id="authUrl" value="http://120.55.85.213:8081" placeholder="http://æœåŠ¡å™¨IP:ç«¯å£">
                    </div>
                    <div class="form-group">
                        <label for="internalIp">å†…éƒ¨æœºIP(ç›´è¿ç”¨):</label>
                        <input type="text" id="internalIp" value="192.168.50.44" placeholder="ä¾‹å¦‚ 192.168.50.44">
                    </div>
                </div>
                <div>
                    <div class="form-group">
                        <label for="apiKey">API Key <span class="required">*</span>:</label>
                        <input type="password" id="apiKey" placeholder="è¾“å…¥API Key">
                    </div>
                    <div class="form-group">
                        <label>å®¢æˆ·ç«¯ID:</label>
                        <input type="text" id="clientId" readonly>
                    </div>
                </div>
            </div>
            <button class="btn" id="connectBtn" onclick="startConnection()">
                <span class="loading-spinner hidden" id="connectSpinner"></span>
                å¼€å§‹è¿æ¥
            </button>
            <button class="btn btn-secondary hidden" id="cancelBtn" onclick="cancelConnection()">
                âŒ å–æ¶ˆè¿æ¥
            </button>
        </div>

        <!-- è¿æ¥çŠ¶æ€å’Œæ‘„åƒå¤´ä¿¡æ¯ -->
        <div class="section">
            <h2><span class="icon">ğŸ“¡</span>è¿æ¥çŠ¶æ€</h2>
            <div class="grid">
                <div>
                    <p><span class="status-indicator" id="authStatus"></span><span id="authStatusText">ç­‰å¾…è®¤è¯</span></p>
                    <p><span class="status-indicator" id="signalingStatus"></span><span id="signalingStatusText">ç­‰å¾…è¿æ¥</span></p>
                    <p><span class="status-indicator" id="cameraStatus"></span><span id="cameraStatusText">ç­‰å¾…è·å–æ‘„åƒå¤´</span></p>
                    
                    <!-- è¿æ¥æç¤ºä¿¡æ¯ -->
                    <div id="connectionHint" class="alert alert-warning" style="display: none; margin-top: 15px;">
                        <h4 style="margin-bottom: 10px;">ğŸ“ è¿æ¥æç¤º</h4>
                        <div id="connectionHintText"></div>
                    </div>
                </div>
                <div id="deviceInfo" class="device-info hidden">
                    <h4>å·²è¿æ¥æ‘„åƒå¤´</h4>
                    <div id="deviceDetails"></div>
                </div>
            </div>
            <!-- æ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´é€‰æ‹©åŒºåŸŸï¼ˆåœ¨å‘ç°å¤šä¸ªæ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´æ—¶æ˜¾ç¤ºï¼‰ -->
            <div id="manualCameraSelection" class="device-info hidden" style="margin-top: 15px;">
                <h4>é€‰æ‹©â€œæ‰‹åŠ¨å½•å…¥â€æ‘„åƒå¤´</h4>
                <div class="form-group">
                    <label for="cameraSelect">å¯ç”¨æ‘„åƒå¤´:</label>
                    <select id="cameraSelect"></select>
                </div>
                <button class="btn btn-success" id="connectCameraBtn" onclick="connectSelectedCamera()" disabled>
                    è¿æ¥æ‰€é€‰æ‘„åƒå¤´
                </button>
                <button class="btn btn-success hidden" id="connectLanCameraBtn" onclick="connectSelectedLanCamera()">
                    è¿æ¥æ‰€é€‰æ‘„åƒå¤´ï¼ˆç›´è¿ï¼‰
                </button>
            </div>
        </div>

        <!-- äººè„¸æ‹æ‘„å’Œä¿¡æ¯å½•å…¥ -->
        <div class="section">
            <h2><span class="icon">ğŸ‘¤</span>äººè„¸æ‹æ‘„å’Œä¿¡æ¯å½•å…¥</h2>
            <div class="grid">
                <!-- å·¦ä¾§ï¼šè§†é¢‘æ‹æ‘„åŒºåŸŸ -->
                <div>
                    <h3>å®æ—¶è§†é¢‘æµ</h3>
                    <div class="video-container" id="videoContainer">
                        <div class="video-placeholder">
                            <div style="font-size: 3em; margin-bottom: 20px;">ğŸ“¹</div>
                            <div>ç­‰å¾…è¿æ¥æ‘„åƒå¤´...</div>
                        </div>
                    </div>
                    <button class="btn btn-success" id="captureBtn" onclick="captureImage()" disabled>
                        ğŸ“¸ æ‹æ‘„å›¾åƒ
                    </button>
                    <button class="btn" id="uploadBtn" onclick="openImageUpload()">
                        ğŸ–¼ï¸ äººè„¸å›¾åƒä¸Šä¼ 
                    </button>
                    <input type="file" id="uploadInput" accept="image/*" class="hidden" />
                    
                    <h3 style="margin-top: 20px;">æ‹æ‘„ç»“æœ</h3>
                    <div class="capture-area" id="captureArea">
                        <p id="captureHint">è¯·å…ˆè¿æ¥æ‘„åƒå¤´å¹¶ç‚¹å‡»æ‹æ‘„æˆ–ä¸Šä¼ æŒ‰é’®</p>
                    </div>
                </div>

                <!-- å³ä¾§ï¼šäººå‘˜ä¿¡æ¯å½•å…¥è¡¨å• -->
                <div>
                    <h3>äººå‘˜ä¿¡æ¯å½•å…¥</h3>
                    <div class="registration-form">
                        <div id="formValidationMessage" class="alert alert-warning" style="display: none;"></div>
                        
                        <div class="form-group">
                            <label for="personName">å§“å <span class="required">*</span>:</label>
                            <input type="text" id="personName" placeholder="è¯·è¾“å…¥å§“å" required>
                            <div class="validation-error" id="personNameError"></div>
                        </div>
                        
                        <div class="form-group">
                            <label for="personType">äººå‘˜ç±»å‹ <span class="required">*</span>:</label>
                            <select id="personType" required>
                                <option value="">è¯·é€‰æ‹©äººå‘˜ç±»å‹</option>
                            </select>
                            <div class="validation-error" id="personTypeError"></div>
                        </div>
                        
                        <div class="form-group">
                            <label for="roomId">æˆ¿é—´å·:</label>
                            <input type="text" id="roomId" placeholder="è¯·è¾“å…¥æˆ¿é—´å·">
                            <div class="validation-error" id="roomIdError"></div>
                        </div>
                        
                        <div class="form-group">
                            <label for="phoneNumber">æ‰‹æœºå·:</label>
                            <input type="tel" id="phoneNumber" placeholder="è¯·è¾“å…¥11ä½æ‰‹æœºå·">
                            <div class="validation-error" id="phoneNumberError"></div>
                        </div>
                        
                        <div class="form-group">
                            <label for="idCardNumber">èº«ä»½è¯å·:</label>
                            <input type="text" id="idCardNumber" placeholder="è¯·è¾“å…¥18ä½èº«ä»½è¯å·">
                            <div class="validation-error" id="idCardNumberError"></div>
                        </div>
                        
                        <div class="form-group">
                            <label for="location">å½•å…¥ä½ç½®:</label>
                            <input type="text" id="location" placeholder="ç­‰å¾…æ‘„åƒå¤´è¿æ¥..." readonly>
                            <div class="validation-error" id="locationError"></div>
                        </div>
                        
                        <!-- ç›´è¿æ¨¡å¼ï¼šè®¾å¤‡IDè¾“å…¥ -->
                        <div class="form-group hidden" id="deviceIdGroup">
                            <label for="deviceIdInput">è®¾å¤‡ID (ç›´è¿æ¨¡å¼) <span class="required">*</span>:</label>
                            <input type="text" id="deviceIdInput" placeholder="è¯·è¾“å…¥ç”¨äºå…¥åº“çš„è®¾å¤‡ID">
                            <div class="validation-error" id="deviceIdError"></div>
                        </div>
                        
                        <div class="form-group">
                            <button class="btn btn-success" id="submitBtn" onclick="submitRegistration()" disabled>
                                ğŸ’¾ æäº¤å…¥åº“
                            </button>
                            <button class="btn btn-warning" onclick="resetForm()">
                                ğŸ”„ é‡æ–°æ‹æ‘„
                            </button>
                        </div>
                        <div id="registrationResult"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- è¿›åº¦æ¡ -->
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <!-- æ—¥å¿—åŒºåŸŸ -->
        <div class="section">
            <h2><span class="icon">ğŸ“‹</span>æ“ä½œæ—¥å¿—</h2>
            <button class="btn btn-warning" onclick="clearLogs()">æ¸…ç©ºæ—¥å¿—</button>
            <div class="log-area" id="logArea"></div>
        </div>
    </div>

    <!-- å¼•å…¥åˆ†ç‰‡å¤„ç†å™¨ -->
    <script src="webrtc_chunker.js"></script>
    <script>
        // å…¨å±€å˜é‡
        let authToken = null;
        let ws = null;
        let peerConnection = null;
        let dataChannel = null;
        let apiClient = null;
        let webrtcChunker = null;
        let selectedClient = null;
        let selectedCamera = null;
        let selectedCameraType = 'local';
        let clientID = generateClientId();
        let currentStep = 1;
        let profileTypes = [];
        let capturedImageData = null;
        let croppedFaceImageData = null;  // å­˜å‚¨è£å‰ªåçš„äººè„¸å›¾åƒ
        let detectedFaces = [];
        let deviceId = null;
        let profileTypesLoaded = false;  // æ·»åŠ äººå‘˜ç±»å‹åŠ è½½çŠ¶æ€æ ‡è®°
        let isProcessing = false;        // æ·»åŠ å¤„ç†çŠ¶æ€æ ‡è®°ï¼Œé˜²æ­¢å¹¶å‘è¯·æ±‚
        let networkMode = 'remote';      // 'lan' æˆ– 'remote'
        let manualCameras = [];          // å‘ç°çš„æ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´åˆ—è¡¨
        let pendingConnectResolve = null; // å»¶è¿Ÿresolveä»¥ç­‰å¾…ç”¨æˆ·é€‰æ‹©æ‘„åƒå¤´
        let pendingConnectReject = null;  // å»¶è¿Ÿrejectä»¥ç­‰å¾…ç”¨æˆ·é€‰æ‹©æ‘„åƒå¤´
        
        // è¿æ¥çŠ¶æ€å’Œé‡è¿ç›¸å…³å˜é‡
        let connectionTimeout = null;    // è¿æ¥è¶…æ—¶å®šæ—¶å™¨
        let videoStreamTimeout = null;   // è§†é¢‘æµè¶…æ—¶å®šæ—¶å™¨
        let reconnectAttempts = 0;       // é‡è¿å°è¯•æ¬¡æ•°
        let maxReconnectAttempts = 3;    // æœ€å¤§é‡è¿æ¬¡æ•°
        let isReconnecting = false;      // æ˜¯å¦æ­£åœ¨é‡è¿
        let connectionStartTime = 0;     // è¿æ¥å¼€å§‹æ—¶é—´
        let isConnectionEstablished = false;  // è¿æ¥æ˜¯å¦å·²å»ºç«‹
        let localStream = null;          // æœ¬æœºæ‘„åƒå¤´æµï¼ˆç›´è¿æ¨¡å¼ï¼‰
        let lanBaseUrl = null;           // å±€åŸŸç½‘ç›´è¿APIåŸºåœ°å€
        let lanPreviewTimer = null;      // å±€åŸŸç½‘å¿«ç…§é¢„è§ˆå®šæ—¶å™¨
        let lanCameras = [];             // å±€åŸŸç½‘æ‘„åƒå¤´åˆ—è¡¨ï¼ˆæ‰‹åŠ¨å½•å…¥ï¼‰

        // WebRTCé…ç½® - ä¿®å¤mDNSè§£æé—®é¢˜å¹¶æ·»åŠ åŸå§‹TURNæœåŠ¡å™¨
        const rtcConfig = {
            iceServers: [
                // æ ¸å¿ƒSTUNæœåŠ¡å™¨ - ä¼˜å…ˆä½¿ç”¨å¤šä¸ªGoogle STUNæœåŠ¡å™¨
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                // æ·»åŠ å¤‡ç”¨STUNæœåŠ¡å™¨æé«˜æˆåŠŸç‡
                { urls: 'stun:stun.cloudflare.com:3478' },
                { urls: 'stun:stun.nextcloud.com:443' },
                // è‡ªå®šä¹‰TURNæœåŠ¡å™¨ï¼ˆä¸»è¦ä¸­ç»§æœåŠ¡å™¨ï¼‰
                { 
                    urls: ['turn:120.55.85.213:3478?transport=udp', 'turn:120.55.85.213:3478?transport=tcp'], 
                    username: "cenyc", 
                    credential: "cenyc" 
                },
                // å…¬å…±TURNæœåŠ¡å™¨ä½œä¸ºå¤‡é€‰ - æä¾›å¤šåè®®æ”¯æŒ
                { 
                    urls: ['turn:openrelay.metered.ca:80?transport=tcp', 'turn:openrelay.metered.ca:80?transport=udp'], 
                    username: "openrelayproject", 
                    credential: "openrelayproject" 
                },
                { 
                    urls: ['turn:openrelay.metered.ca:443?transport=tcp'], 
                    username: "openrelayproject", 
                    credential: "openrelayproject" 
                },
                // æ›´å¤šå¤‡ç”¨TURNæœåŠ¡å™¨
                { 
                    urls: 'turn:relay1.expressturn.com:3478', 
                    username: "ef3JIJDP8D8N2VGL6Y", 
                    credential: "zGEhi6EL8mTIJlm8" 
                }
            ],
            // ä¼˜åŒ–ICEé…ç½®å‚æ•° - å…è®¸æ‰€æœ‰è¿æ¥ç±»å‹ä½†é¿å…mDNS
            iceCandidatePoolSize: 10,        // é¢„ç”Ÿæˆæ›´å¤šICEå€™é€‰
            bundlePolicy: 'max-bundle',      // æœ€å¤§åŒ–åª’ä½“æµå¤ç”¨
            rtcpMuxPolicy: 'require',        // å¼ºåˆ¶RTCPå¤ç”¨
            iceTransportPolicy: 'all'        // å…è®¸æ‰€æœ‰ä¼ è¾“ç±»å‹ä»¥æé«˜è¿æ¥æˆåŠŸç‡
        };

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('clientId').value = clientID;
            log('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', 'info');
            log(`å®¢æˆ·ç«¯ID: ${clientID}`, 'info');
            updateProgress(0);
            
            // ç»‘å®šè¡¨å•éªŒè¯äº‹ä»¶
            setupFormValidation();

            // ç»‘å®šä¸Šä¼ äº‹ä»¶
            const uploadInput = document.getElementById('uploadInput');
            if (uploadInput) {
                uploadInput.addEventListener('change', handleImageFileChange);
            }
        });
        
        // HTTPç›´è¿ API å®¢æˆ·ç«¯
        class HttpAPIClient {
            constructor(baseUrl) {
                this.baseUrl = baseUrl.replace(/\/$/, '');
            }
            async get(endpoint) {
                const url = this.baseUrl + endpoint;
                const resp = await fetch(url, { method: 'GET' });
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                return await resp.json();
            }
            async post(endpoint, data) {
                const url = this.baseUrl + endpoint;
                const resp = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                const json = await resp.json().catch(() => ({ success: false, error: 'Invalid JSON' }));
                if (!resp.ok || json.success === false) {
                    const err = new Error(json.error || json.detail || `HTTP ${resp.status}`);
                    err.response = json;
                    throw err;
                }
                return json;
            }
        }

        // æ¢æµ‹ç½‘ç»œç¯å¢ƒï¼ˆä¼˜å…ˆç›´è¿WebAPIï¼‰
        async function detectNetworkEnvironment() {
            const internalIp = (document.getElementById('internalIp')?.value || '').trim();
            if (!internalIp) return 'remote';
            const baseLanUrl = `http://${internalIp}:5001`;
            const statusUrl = `${baseLanUrl}/api/status`;
            log(`æ£€æµ‹ç½‘ç»œç¯å¢ƒ: æ¢æµ‹ ${statusUrl}`, 'info');
            try {
                const controller = new AbortController();
                const timer = setTimeout(() => controller.abort(), 2500);
                const resp = await fetch(statusUrl, { signal: controller.signal, cache: 'no-store' });
                clearTimeout(timer);
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const data = await resp.json().catch(() => ({}));
                if (data && data.success) {
                    log('æ£€æµ‹åˆ°å±€åŸŸç½‘å¯ç›´è¿WebAPIï¼Œå°†èµ°ç›´è¿æ¨¡å¼', 'success');
                    return 'lan';
                }
            } catch (e) {
                log(`ç›´è¿æ¢æµ‹å¤±è´¥ï¼Œä½¿ç”¨WebRTCè¿œç¨‹æ¨¡å¼: ${e.message}`, 'warning');
            }
            return 'remote';
        }

        // å¯ç”¨æœ¬æœºæ‘„åƒå¤´ï¼ˆç›´è¿æ¨¡å¼ï¼‰
        async function enableLocalCamera() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    log('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®', 'error');
                    return;
                }
                if (localStream) {
                    // å·²å¼€å¯
                    log('æœ¬æœºæ‘„åƒå¤´å·²å¯ç”¨', 'info');
                    return;
                }
                const constraints = { video: { width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                let video = document.getElementById('videoContainer').querySelector('video');
                if (!video) {
                    video = document.createElement('video');
                    video.autoplay = true;
                    video.muted = true;
                    video.playsInline = true;
                    video.style.width = '100%';
                    video.style.height = '100%';
                    video.style.objectFit = 'contain';
                    document.getElementById('videoContainer').innerHTML = '';
                    document.getElementById('videoContainer').appendChild(video);
                }
                video.srcObject = localStream;
                document.getElementById('captureBtn').disabled = false;
                updateStatus('cameraStatus', 'cameraStatusText', 'success', 'å·²å¯ç”¨æœ¬æœºæ‘„åƒå¤´');
                log('âœ… å·²å¯ç”¨æœ¬æœºæ‘„åƒå¤´', 'success');
            } catch (err) {
                log(`å¯ç”¨æœ¬æœºæ‘„åƒå¤´å¤±è´¥: ${err.message}`, 'error');
            }
        }

        // åŠ è½½å±€åŸŸç½‘â€œæ‰‹åŠ¨å½•å…¥â€æ‘„åƒå¤´åˆ—è¡¨
        async function loadLanManualCameras() {
            try {
                updateStatus('cameraStatus', 'cameraStatusText', 'warning', 'æŸ¥è¯¢å±€åŸŸç½‘æ‘„åƒå¤´ä¸­...');
                const resp = await apiClient.get('/api/camera/list?func_type=2');
                if (!resp.success) throw new Error(resp.error || 'æŸ¥è¯¢å¤±è´¥');

                lanCameras = resp.devices || [];
                if (lanCameras.length === 0) {
                    updateStatus('cameraStatus', 'cameraStatusText', 'error', 'æœªå‘ç°æ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´');
                    log('æœªå‘ç°func_type=2çš„æ‘„åƒå¤´', 'warning');
                    return;
                }

                if (lanCameras.length === 1) {
                    const dev = lanCameras[0];
                    await setupLanCamera(dev);
                    return;
                }

                // å¤šä¸ªï¼šå±•ç¤ºé€‰æ‹©åŒºï¼ˆå¤ç”¨åŸæœ‰UIï¼‰
                const container = document.getElementById('manualCameraSelection');
                const selectEl = document.getElementById('cameraSelect');
                const webrtcBtn = document.getElementById('connectCameraBtn');
                const lanBtn = document.getElementById('connectLanCameraBtn');
                if (container && selectEl && lanBtn) {
                    container.classList.remove('hidden');
                    selectEl.innerHTML = '';
                    lanCameras.forEach((cam, idx) => {
                        const opt = document.createElement('option');
                        opt.value = String(idx);
                        opt.textContent = `${cam.name} (${cam.type}) ${cam.resolution} @ ${cam.fps}fps`;
                        selectEl.appendChild(opt);
                    });
                    if (webrtcBtn) webrtcBtn.classList.add('hidden');
                    lanBtn.classList.remove('hidden');
                }

                updateStatus('cameraStatus', 'cameraStatusText', 'info', `å‘ç° ${lanCameras.length} ä¸ªæ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´ï¼Œè¯·é€‰æ‹©`);
            } catch (e) {
                log(`å±€åŸŸç½‘æ‘„åƒå¤´æŸ¥è¯¢å¤±è´¥: ${e.message}`, 'error');
                updateStatus('cameraStatus', 'cameraStatusText', 'error', 'æŸ¥è¯¢å¤±è´¥');
            }
        }

        async function connectSelectedLanCamera() {
            try {
                const selectEl = document.getElementById('cameraSelect');
                const idx = parseInt(selectEl?.value || '-1');
                if (isNaN(idx) || idx < 0 || idx >= lanCameras.length) {
                    log('è¯·é€‰æ‹©ä¸€ä¸ªæœ‰æ•ˆçš„æ‘„åƒå¤´', 'warning');
                    return;
                }
                await setupLanCamera(lanCameras[idx]);
            } catch (e) {
                log(`ç›´è¿æ‘„åƒå¤´è¿æ¥å¤±è´¥: ${e.message}`, 'error');
            }
        }

        async function setupLanCamera(dev) {
            try {
                // éšè—é€‰æ‹©åŒº
                const container = document.getElementById('manualCameraSelection');
                if (container) container.classList.add('hidden');

                // å¡«å……è®¾å¤‡ä¿¡æ¯
                deviceId = dev.device_id;
                const deviceInfo = document.getElementById('deviceInfo');
                const deviceDetails = document.getElementById('deviceDetails');
                deviceInfo.classList.remove('hidden');
                deviceDetails.innerHTML = `
                    <p><strong>è®¾å¤‡:</strong> ${dev.name}</p>
                    <p><strong>ä½ç½®:</strong> ${dev.location}</p>
                    <p><strong>ç±»å‹:</strong> ${dev.type}</p>
                    <p><strong>åˆ†è¾¨ç‡:</strong> ${dev.resolution} @ ${dev.fps}fps</p>
                `;
                const locationInput = document.getElementById('location');
                if (locationInput) locationInput.value = dev.location || dev.name || 'äººè„¸å½•å…¥ç³»ç»Ÿ';

                // å¯åŠ¨é¢„è§ˆï¼ˆå¿«ç…§è½®è¯¢ï¼‰
                startLanPreview(dev.device_id);

                // å¯ç”¨æ‹æ‘„æŒ‰é’®
                const capBtn = document.getElementById('captureBtn');
                capBtn.disabled = false;

                updateStatus('cameraStatus', 'cameraStatusText', 'success', 'æ‘„åƒå¤´å·²è¿æ¥ï¼ˆç›´è¿ï¼‰');
                log(`âœ… å·²è¿æ¥ç›´è¿æ‘„åƒå¤´: ${dev.name}`, 'success');
                updateProgress(3);
            } catch (e) {
                log(`è®¾ç½®ç›´è¿æ‘„åƒå¤´å¤±è´¥: ${e.message}`, 'error');
                updateStatus('cameraStatus', 'cameraStatusText', 'error', 'æ‘„åƒå¤´è¿æ¥å¤±è´¥');
            }
        }

        function startLanPreview(devId) {
            try {
                const videoContainer = document.getElementById('videoContainer');
                // å…ˆå°è¯•MJPEGæµ
                videoContainer.innerHTML = '';
                const fps = 20;
                const streamImg = document.createElement('img');
                streamImg.id = 'lanPreview';
                streamImg.style.width = '100%';
                streamImg.style.height = '100%';
                streamImg.style.objectFit = 'contain';
                // è‹¥MJPEGå¤±è´¥ï¼Œå›é€€å¿«ç…§è½®è¯¢
                streamImg.onerror = () => {
                    lanPreviewMode = 'snapshot';
                    startLanSnapshotPreview(devId);
                };
                streamImg.src = `${lanBaseUrl}/api/camera/stream_mjpeg?device_id=${devId}&fps=${fps}&ts=${Date.now()}`;
                videoContainer.appendChild(streamImg);
                lanPreviewMode = 'mjpeg';
                // æ¸…ç†å¿«ç…§è½®è¯¢ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (lanPreviewTimer) {
                    clearInterval(lanPreviewTimer);
                    lanPreviewTimer = null;
                }
            } catch (e) {
                log(`å¯åŠ¨ç›´è¿é¢„è§ˆå¤±è´¥: ${e.message}`, 'error');
            }
        }

        function startLanSnapshotPreview(devId) {
            const videoContainer = document.getElementById('videoContainer');
            videoContainer.innerHTML = '';
            const img = document.createElement('img');
            img.id = 'lanPreview';
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'contain';
            videoContainer.appendChild(img);
            if (lanPreviewTimer) {
                clearInterval(lanPreviewTimer);
                lanPreviewTimer = null;
            }
            const update = () => {
                const ts = Date.now();
                img.src = `${lanBaseUrl}/api/camera/snapshot?device_id=${devId}&ts=${ts}`;
            };
            const interval = 50; // 20fps
            update();
            lanPreviewTimer = setInterval(update, interval);
        }

        // è®¾ç½®è¡¨å•éªŒè¯
        function setupFormValidation() {
            const formFields = ['personName', 'personType', 'phoneNumber', 'idCardNumber', 'roomId'];
            
            formFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('blur', () => validateField(fieldId));
                    field.addEventListener('input', () => {
                        clearFieldError(fieldId);
                        updateSubmitButton();
                    });
                }
            });
        }

        // æ‰“å¼€æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†
        function openImageUpload() {
            const input = document.getElementById('uploadInput');
            if (!input) return;

            if (!apiClient) {
                log('APIå®¢æˆ·ç«¯æœªåˆå§‹åŒ–ï¼Œè¯·å…ˆè¿æ¥æœåŠ¡å™¨/æ‘„åƒå¤´', 'warning');
            }
            input.value = '';
            input.click();
        }

        // å¤„ç†å›¾åƒæ–‡ä»¶é€‰æ‹©
        async function handleImageFileChange(event) {
            const file = event.target.files && event.target.files[0];
            if (!file) return;

            // æ£€æŸ¥æ˜¯å¦æ­£åœ¨å¤„ç†å…¶ä»–è¯·æ±‚
            if (isProcessing) {
                log('ç³»ç»Ÿæ­£åœ¨å¤„ç†å…¶ä»–è¯·æ±‚ï¼Œè¯·ç¨åé‡è¯•', 'warning');
                return;
            }

            // æ£€æŸ¥äººå‘˜ç±»å‹æ˜¯å¦å·²åŠ è½½
            if (!profileTypesLoaded && apiClient) {
                log('äººå‘˜ç±»å‹æ•°æ®å°šæœªåŠ è½½ï¼Œæ­£åœ¨å°è¯•åŠ è½½...', 'info');
                try {
                    await loadProfileTypes();
                } catch (e) {
                    // å¿½ç•¥ï¼Œåç»­é€»è¾‘ä¼šæ ¹æ®profileTypesLoadedå¤„ç†
                }
            }

            if (!/^image\//.test(file.type)) {
                log('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼ˆJPG/PNGç­‰ï¼‰', 'error');
                return;
            }

            if (file.size > 10 * 1024 * 1024) { // 10MBä¸Šé™
                log('å›¾ç‰‡è¿‡å¤§ï¼Œè¯·é€‰æ‹©å°äº10MBçš„å›¾ç‰‡', 'error');
                return;
            }

            try {
                isProcessing = true;  // è®¾ç½®å¤„ç†çŠ¶æ€
                log(`å¼€å§‹åŠ è½½æœ¬åœ°å›¾åƒ: ${file.name}`, 'info');

                const dataUrl = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(new Error('è¯»å–å›¾ç‰‡å¤±è´¥'));
                    reader.readAsDataURL(file);
                });

                // ä½¿ç”¨Imageå¯¹è±¡è·å–åŸå›¾å°ºå¯¸
                const imgInfo = await new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
                    img.onerror = () => reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
                    img.src = dataUrl;
                });

                // å°†å›¾åƒæ”¾å…¥æ‹æ‘„åŒºåŸŸå¹¶å‡†å¤‡æ£€æµ‹
                capturedImageData = dataUrl;

                const captureArea = document.getElementById('captureArea');
                captureArea.innerHTML = `
                    <div class="face-detection-overlay" id="faceOverlay">
                        <img class="captured-image" src="${capturedImageData}" alt="ä¸Šä¼ çš„å›¾åƒ" />
                    </div>
                    <p style="margin-top: 10px; color: #28a745; font-weight: bold;">
                        åŸå›¾å°ºå¯¸: ${imgInfo.width} x ${imgInfo.height}
                    </p>
                    <div id="croppedFacePreview" style="margin-top: 15px; display: none;">
                        <h4 style="color: #495057; margin-bottom: 10px;">ğŸ¯ è£å‰ªåçš„äººè„¸å›¾åƒï¼ˆå°†å…¥åº“å­˜å‚¨ï¼‰:</h4>
                        <img id="croppedFaceImage" class="captured-image" style="max-width: 200px; max-height: 200px;" />
                    </div>
                `;

                log(`âœ… æœ¬åœ°å›¾åƒåŠ è½½æˆåŠŸï¼å°ºå¯¸: ${imgInfo.width}x${imgInfo.height}`, 'success');
                updateProgress(3);

                // è‡ªåŠ¨è¿›è¡Œäººè„¸æ£€æµ‹
                await detectFaces();

            } catch (error) {
                log(`âŒ å›¾åƒä¸Šä¼ å¤„ç†å¤±è´¥: ${error.message}`, 'error');
            } finally {
                isProcessing = false;  // æ¸…é™¤å¤„ç†çŠ¶æ€
                updateSubmitButton();
            }
        }
        
        // æ¸…é™¤å­—æ®µé”™è¯¯çŠ¶æ€
        function clearFieldError(fieldId) {
            const field = document.getElementById(fieldId);
            const errorDiv = document.getElementById(fieldId + 'Error');
            
            if (field && errorDiv) {
                field.classList.remove('error');
                errorDiv.textContent = '';
            }
        }
        
        // è®¾ç½®å­—æ®µé”™è¯¯çŠ¶æ€
        function setFieldError(fieldId, message) {
            const field = document.getElementById(fieldId);
            const errorDiv = document.getElementById(fieldId + 'Error');
            
            if (field && errorDiv) {
                field.classList.add('error');
                field.classList.remove('valid');
                errorDiv.textContent = message;
            }
        }
        
        // è®¾ç½®å­—æ®µæœ‰æ•ˆçŠ¶æ€
        function setFieldValid(fieldId) {
            const field = document.getElementById(fieldId);
            const errorDiv = document.getElementById(fieldId + 'Error');
            
            if (field && errorDiv) {
                field.classList.remove('error');
                field.classList.add('valid');
                errorDiv.textContent = '';
            }
        }
        
        // éªŒè¯å•ä¸ªå­—æ®µ
        function validateField(fieldId) {
            const field = document.getElementById(fieldId);
            if (!field) return true;
            
            const value = field.value.trim();
            
            switch (fieldId) {
                case 'personName':
                    if (!value) {
                        setFieldError(fieldId, 'è¯·è¾“å…¥å§“å');
                        return false;
                    } else if (value.length < 2) {
                        setFieldError(fieldId, 'å§“åè‡³å°‘éœ€è¦2ä¸ªå­—ç¬¦');
                        return false;
                    } else if (value.length > 50) {
                        setFieldError(fieldId, 'å§“åä¸èƒ½è¶…è¿‡50ä¸ªå­—ç¬¦');
                        return false;
                    } else if (!/^[\u4e00-\u9fa5a-zA-Z\s]+$/.test(value)) {
                        setFieldError(fieldId, 'å§“ååªèƒ½åŒ…å«ä¸­æ–‡ã€è‹±æ–‡å’Œç©ºæ ¼');
                        return false;
                    }
                    break;
                    
                case 'personType':
                    if (!value) {
                        setFieldError(fieldId, 'è¯·é€‰æ‹©äººå‘˜ç±»å‹');
                        return false;
                    }
                    break;
                    
                case 'phoneNumber':
                    if (value && !/^1[3-9]\d{9}$/.test(value)) {
                        setFieldError(fieldId, 'è¯·è¾“å…¥æ­£ç¡®çš„11ä½æ‰‹æœºå·');
                        return false;
                    }
                    break;
                    
                case 'idCardNumber':
                    if (value) {
                        if (!/^\d{17}[\dXx]$/.test(value)) {
                            setFieldError(fieldId, 'è¯·è¾“å…¥æ­£ç¡®çš„18ä½èº«ä»½è¯å·');
                            return false;
                        }
                        // èº«ä»½è¯æ ¡éªŒç®—æ³•
                        if (!validateIdCard(value)) {
                            setFieldError(fieldId, 'èº«ä»½è¯å·ç æ ¼å¼ä¸æ­£ç¡®');
                            return false;
                        }
                    }
                    break;
                    
                case 'roomId':
                    if (value && (value.length > 20 || !/^[a-zA-Z0-9\u4e00-\u9fa5-]+$/.test(value))) {
                        setFieldError(fieldId, 'æˆ¿é—´å·æ ¼å¼ä¸æ­£ç¡®ï¼ˆæœ€å¤š20å­—ç¬¦ï¼Œæ”¯æŒä¸­è‹±æ–‡æ•°å­—å’Œè¿å­—ç¬¦ï¼‰');
                        return false;
                    }
                    break;
            }
            
            setFieldValid(fieldId);
            return true;
        }
        
        // èº«ä»½è¯å·éªŒè¯
        function validateIdCard(idCard) {
            const weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
            const checkCodes = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];
            
            let sum = 0;
            for (let i = 0; i < 17; i++) {
                sum += parseInt(idCard.charAt(i)) * weights[i];
            }
            
            const checkCode = checkCodes[sum % 11];
            return idCard.charAt(17).toUpperCase() === checkCode;
        }
        
        // éªŒè¯æ•´ä¸ªè¡¨å•
        function validateForm() {
            const fields = ['personName', 'personType'];
            let isValid = true;
            
            // éªŒè¯å¿…å¡«å­—æ®µ
            fields.forEach(fieldId => {
                if (!validateField(fieldId)) {
                    isValid = false;
                }
            });
            
            // éªŒè¯å¯é€‰å­—æ®µ
            const optionalFields = ['phoneNumber', 'idCardNumber', 'roomId'];
            optionalFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field && field.value.trim()) {
                    if (!validateField(fieldId)) {
                        isValid = false;
                    }
                }
            });
            
            // æ£€æŸ¥æ˜¯å¦å·²æ‹æ‘„å¹¶è£å‰ªäººè„¸
            if (!croppedFaceImageData || detectedFaces.length !== 1) {
                const messageDiv = document.getElementById('formValidationMessage');
                if (detectedFaces.length === 0) {
                    messageDiv.textContent = 'è¯·å…ˆæ‹æ‘„äººè„¸å›¾åƒ';
                } else if (detectedFaces.length > 1) {
                    messageDiv.textContent = `æ£€æµ‹åˆ°${detectedFaces.length}å¼ äººè„¸ï¼Œè¯·ç¡®ä¿å›¾ç‰‡ä¸­åªæœ‰ä¸€å¼ äººè„¸`;
                } else if (!croppedFaceImageData) {
                    messageDiv.textContent = 'äººè„¸è£å‰ªå¤±è´¥ï¼Œè¯·é‡æ–°æ‹æ‘„';
                } else {
                    messageDiv.textContent = 'è¯·å…ˆå®Œæˆäººè„¸æ‹æ‘„';
                }
                messageDiv.style.display = 'block';
                isValid = false;
            } else {
                document.getElementById('formValidationMessage').style.display = 'none';
            }
            
            return isValid;
        }
        
        // æ›´æ–°æäº¤æŒ‰é’®çŠ¶æ€
        function updateSubmitButton() {
            const submitBtn = document.getElementById('submitBtn');
            const hasValidCapture = croppedFaceImageData && detectedFaces.length === 1;
            const hasRequiredFields = document.getElementById('personName').value.trim() && 
                                    document.getElementById('personType').value;
            const lanDeviceOk = (networkMode !== 'lan') || ((document.getElementById('deviceIdInput')?.value || '').trim().length > 0 || !!deviceId);
            
            if (hasValidCapture && hasRequiredFields && lanDeviceOk && !isProcessing) {
                submitBtn.disabled = false;
                submitBtn.classList.remove('btn-disabled');
            } else {
                submitBtn.disabled = true;
                submitBtn.classList.add('btn-disabled');
            }
        }
        
        // è®¡ç®—è£å‰ªåŒºåŸŸï¼ˆç»Ÿä¸€å‡½æ•°ï¼Œæ·»åŠ è¾¹ç•Œæ£€æŸ¥å’Œä¼˜åŒ–ï¼‰
        function calculateCropRegion(faceBox, imgWidth, imgHeight) {
            const [x, y, w, h] = faceBox;
            
            // æ·»åŠ è¾¹ç•Œæ£€æŸ¥ï¼Œç¡®ä¿è£å‰ªåŒºåŸŸåœ¨å›¾åƒèŒƒå›´å†…
            const cropX = Math.max(0, Math.min(Math.round(x), imgWidth - 1));
            const cropY = Math.max(0, Math.min(Math.round(y), imgHeight - 1));
            
            // ç¡®ä¿å®½åº¦å’Œé«˜åº¦ä¸è¶…å‡ºå›¾åƒè¾¹ç•Œ
            const maxWidth = imgWidth - cropX;
            const maxHeight = imgHeight - cropY;
            const cropW = Math.min(Math.round(w), maxWidth);
            const cropH = Math.min(Math.round(h), maxHeight);
            
            // ç¡®ä¿è‡³å°‘æœ‰æœ€å°çš„æœ‰æ•ˆåŒºåŸŸ
            const finalCropW = Math.max(1, cropW);
            const finalCropH = Math.max(1, cropH);
            
            console.log(`è£å‰ªåŒºåŸŸè®¡ç®—: åŸå§‹(${x},${y},${w},${h}) -> ä¿®æ­£(${cropX},${cropY},${finalCropW},${finalCropH})`);
            
            return { 
                cropX: cropX, 
                cropY: cropY, 
                cropW: finalCropW, 
                cropH: finalCropH 
            };
        }

        // ä»å®Œæ•´å›¾åƒä¸­è£å‰ªäººè„¸åŒºåŸŸ
        function cropFaceFromImage(imageData, faceBox) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    // ä½¿ç”¨naturalWidthå’ŒnaturalHeightï¼Œç¡®ä¿ä¸ç»¿æ¡†æ˜¾ç¤ºä½¿ç”¨ç›¸åŒçš„åæ ‡ç³»ç»Ÿ
                    const imgWidth = img.naturalWidth || img.width;
                    const imgHeight = img.naturalHeight || img.height;
                    const { cropX, cropY, cropW, cropH } = calculateCropRegion(faceBox, imgWidth, imgHeight);
                    
                    console.log(`è£å‰ªå›¾åƒ: å›¾åƒå°ºå¯¸=${imgWidth}x${imgHeight}, è£å‰ªåŒºåŸŸ=(${cropX},${cropY},${cropW},${cropH})`);
                    
                    // åˆ›å»ºcanvasè¿›è¡Œè£å‰ª
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = cropW;
                    canvas.height = cropH;
                    
                    // è£å‰ªäººè„¸åŒºåŸŸ
                    ctx.drawImage(img, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);
                    
                    // è½¬æ¢ä¸ºBase64
                    const croppedImageData = canvas.toDataURL('image/jpeg', 0.95);
                    resolve(croppedImageData);
                };
                img.src = imageData;
            });
        }

        // ç”Ÿæˆå®¢æˆ·ç«¯ID
        function generateClientId() {
            const timestamp = Date.now();
            const randomSuffix = Math.random().toString(36).substring(2, 8);
            return `face_reg_client_${timestamp}_${randomSuffix}`;
        }

        // æ¸…ç†æ‰€æœ‰è¶…æ—¶å®šæ—¶å™¨
        function clearAllTimeouts() {
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
                connectionTimeout = null;
            }
            if (videoStreamTimeout) {
                clearTimeout(videoStreamTimeout);
                videoStreamTimeout = null;
            }
        }

        // æ˜¾ç¤ºé‡è¿çŠ¶æ€
        function showReconnectStatus(message, attempt = 0) {
            const videoContainer = document.getElementById('videoContainer');
            const reconnectHtml = `
                <div class="video-placeholder" style="color: #ffc107;">
                    <div style="font-size: 2em; margin-bottom: 15px;">ğŸ”„</div>
                    <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">${message}</div>
                    ${attempt > 0 ? `<div style="font-size: 0.9em; color: #6c757d;">å°è¯•æ¬¡æ•°: ${attempt}/${maxReconnectAttempts}</div>` : ''}
                    <div class="loading-spinner" style="margin-top: 15px;"></div>
                </div>
            `;
            videoContainer.innerHTML = reconnectHtml;
        }

        // æ˜¾ç¤ºè¿æ¥å¤±è´¥çŠ¶æ€
        function showConnectionFailedStatus(message, canRetry = true) {
            const videoContainer = document.getElementById('videoContainer');
            const failedHtml = `
                <div class="video-placeholder" style="color: #dc3545;">
                    <div style="font-size: 2em; margin-bottom: 15px;">âŒ</div>
                    <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 15px;">${message}</div>
                    ${canRetry ? `
                        <button class="btn btn-warning" onclick="manualReconnect()" style="margin-top: 10px;">
                            ğŸ”„ æ‰‹åŠ¨é‡è¯•è¿æ¥
                        </button>
                    ` : ''}
                </div>
            `;
            videoContainer.innerHTML = failedHtml;
        }

        // æ‰‹åŠ¨é‡è¿
        function manualReconnect() {
            if (isReconnecting) {
                log('æ­£åœ¨é‡è¿ä¸­ï¼Œè¯·ç¨å€™...', 'warning');
                return;
            }
            
            reconnectAttempts = 0;
            log('ç”¨æˆ·æ‰‹åŠ¨è§¦å‘é‡è¿', 'info');
            startConnection();
        }

        // å–æ¶ˆè¿æ¥
        function cancelConnection() {
            log('ç”¨æˆ·å–æ¶ˆè¿æ¥', 'info');
            isReconnecting = false;
            clearAllTimeouts();
            
            // æ¸…ç†è¿æ¥çŠ¶æ€
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (ws) {
                ws.close();
                ws = null;
            }
            
            hideLoading('connectBtn', 'connectSpinner');
            hideCancelButton();
            hideConnectionHint();
            
            // é‡ç½®çŠ¶æ€æŒ‡ç¤ºå™¨
            updateStatus('authStatus', 'authStatusText', 'info', 'å·²å–æ¶ˆ');
            updateStatus('signalingStatus', 'signalingStatusText', 'info', 'å·²å–æ¶ˆ');
            updateStatus('cameraStatus', 'cameraStatusText', 'info', 'å·²å–æ¶ˆ');
            
            // é‡ç½®è§†é¢‘å®¹å™¨
            const videoContainer = document.getElementById('videoContainer');
            videoContainer.innerHTML = `
                <div class="video-placeholder">
                    <div style="font-size: 3em; margin-bottom: 20px;">ğŸ“¹</div>
                    <div>ç­‰å¾…è¿æ¥æ‘„åƒå¤´...</div>
                </div>
            `;
            
            updateProgress(1);
        }

        // æ˜¾ç¤º/éšè—å–æ¶ˆæŒ‰é’®
        function showCancelButton() {
            document.getElementById('cancelBtn').classList.remove('hidden');
        }

        function hideCancelButton() {
            document.getElementById('cancelBtn').classList.add('hidden');
        }

        // æ˜¾ç¤ºè¿æ¥æç¤º
        function showConnectionHint(message, type = 'warning') {
            const hintDiv = document.getElementById('connectionHint');
            const hintText = document.getElementById('connectionHintText');
            
            hintDiv.className = `alert alert-${type}`;
            hintText.innerHTML = message;
            hintDiv.style.display = 'block';
        }

        // éšè—è¿æ¥æç¤º
        function hideConnectionHint() {
            document.getElementById('connectionHint').style.display = 'none';
        }

        // å¤„ç†è¿æ¥å¤±è´¥
        function handleConnectionFailure(reason) {
            clearAllTimeouts();
            hideLoading('connectBtn', 'connectSpinner');
            
            log(`è¿æ¥å¤±è´¥: ${reason}`, 'error');
            
            // å¦‚æœè¿˜æœ‰é‡è¿æœºä¼šï¼Œè‡ªåŠ¨é‡è¿
            if (reconnectAttempts < maxReconnectAttempts) {
                const delay = Math.min(2000 * Math.pow(2, reconnectAttempts), 10000); // æŒ‡æ•°é€€é¿ï¼Œæœ€å¤§10ç§’
                log(`å°†åœ¨ ${delay/1000} ç§’åè‡ªåŠ¨é‡è¿...`, 'info');
                
                // æ›´æ–°è¿æ¥æç¤ºï¼Œæ˜¾ç¤ºé‡è¿å€’è®¡æ—¶
                showConnectionHint(`
                    <p><strong>âš ï¸ è¿æ¥å¤±è´¥: ${reason}</strong></p>
                    <p>â€¢ å°†åœ¨ ${delay/1000} ç§’åè‡ªåŠ¨é‡è¿ (${reconnectAttempts}/${maxReconnectAttempts})</p>
                    <p>â€¢ å¯èƒ½åŸå› : ç½‘ç»œä¸ç¨³å®šã€STUNæœåŠ¡å™¨é™åˆ¶ã€å†…éƒ¨æœºç¦»çº¿</p>
                    <p>â€¢ æ‚¨å¯ä»¥ç‚¹å‡»"å–æ¶ˆè¿æ¥"åœæ­¢é‡è¯•</p>
                `, 'warning');
                
                setTimeout(() => {
                    if (isReconnecting) { // ç¡®ä¿ç”¨æˆ·æ²¡æœ‰æ‰‹åŠ¨åœæ­¢é‡è¿
                        startConnection();
                    }
                }, delay);
            } else {
                // è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°
                isReconnecting = false;
                hideCancelButton();
                showConnectionFailedStatus(`è¿æ¥å¤±è´¥: ${reason}`, true);
                updateStatus('cameraStatus', 'cameraStatusText', 'error', 'è¿æ¥å¤±è´¥');
                
                // æ˜¾ç¤ºæœ€ç»ˆå¤±è´¥æç¤º
                showConnectionHint(`
                    <p><strong>âŒ è¿æ¥æœ€ç»ˆå¤±è´¥</strong></p>
                    <p>â€¢ å·²å°è¯• ${maxReconnectAttempts} æ¬¡é‡è¿ï¼Œä»æ— æ³•å»ºç«‹è¿æ¥</p>
                    <p>â€¢ å»ºè®®æ£€æŸ¥: ç½‘ç»œè¿æ¥ã€å†…éƒ¨æœºçŠ¶æ€ã€æœåŠ¡å™¨é…ç½®</p>
                    <p>â€¢ æ‚¨å¯ä»¥ç‚¹å‡»è§†é¢‘åŒºåŸŸçš„"æ‰‹åŠ¨é‡è¯•è¿æ¥"å†æ¬¡å°è¯•</p>
                `, 'danger');
            }
        }

        // è¿æ¥æˆåŠŸå¤„ç†
        function handleConnectionSuccess() {
            clearAllTimeouts();
            isConnectionEstablished = true;
            isReconnecting = false;
            reconnectAttempts = 0;
            
            const connectTime = Date.now() - connectionStartTime;
            log(`âœ… è¿æ¥å»ºç«‹æˆåŠŸï¼Œè€—æ—¶: ${connectTime}ms`, 'success');
            hideLoading('connectBtn', 'connectSpinner');
            hideCancelButton();
            
            // æ˜¾ç¤ºæˆåŠŸæç¤º
            showConnectionHint(`
                <p><strong>âœ… è¿æ¥æˆåŠŸï¼</strong></p>
                <p>â€¢ æ‘„åƒå¤´è§†é¢‘æµå·²å°±ç»ªï¼Œå¯ä»¥å¼€å§‹äººè„¸æ‹æ‘„</p>
                <p>â€¢ è¿æ¥è€—æ—¶: ${connectTime}ms</p>
            `, 'success');
            
            // 3ç§’åéšè—æç¤º
            setTimeout(() => {
                hideConnectionHint();
            }, 3000);
        }

        // æ—¥å¿—å‡½æ•°
        function log(message, level = 'info') {
            const logArea = document.getElementById('logArea');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${level}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logArea.appendChild(logEntry);
            logArea.scrollTop = logArea.scrollHeight;
            
            console.log(`[${level.toUpperCase()}] ${message}`);
        }

        // æ¸…ç©ºæ—¥å¿—
        function clearLogs() {
            document.getElementById('logArea').innerHTML = '';
            log('æ—¥å¿—å·²æ¸…ç©º', 'info');
        }

        // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
        function updateStatus(elementId, textElementId, status, text) {
            const indicator = document.getElementById(elementId);
            const textElement = document.getElementById(textElementId);
            
            indicator.className = `status-indicator status-${status}`;
            textElement.textContent = text;
        }

        // æ›´æ–°è¿›åº¦æ¡
        function updateProgress(step) {
            const progress = (step / 5) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
            
            // æ›´æ–°æ­¥éª¤æŒ‡ç¤ºå™¨
            for (let i = 1; i <= 5; i++) {
                const stepElement = document.getElementById(`step${i}`);
                stepElement.classList.remove('active', 'completed');
                
                if (i < step) {
                    stepElement.classList.add('completed');
                } else if (i === step) {
                    stepElement.classList.add('active');
                }
            }
            
            currentStep = step;
        }

        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        function showLoading(buttonId, spinnerId) {
            const button = document.getElementById(buttonId);
            const spinner = document.getElementById(spinnerId);
            if (button && spinner) {
                button.disabled = true;
                spinner.classList.remove('hidden');
            }
        }

        // éšè—åŠ è½½çŠ¶æ€
        function hideLoading(buttonId, spinnerId) {
            const button = document.getElementById(buttonId);
            const spinner = document.getElementById(spinnerId);
            if (button && spinner) {
                button.disabled = false;
                spinner.classList.add('hidden');
            }
        }

        // WebRTC API å®¢æˆ·ç«¯ç±»
        class WebRTCAPIClient {
            constructor(dataChannel) {
                this.dataChannel = dataChannel;
                this.requestId = 0;
                this.pendingRequests = new Map();
                
                this.dataChannel.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸ºåˆ†ç‰‡æ¶ˆæ¯
                        if (webrtcChunker && data.type === 'chunk') {
                            
                            // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯ACKæ¶ˆæ¯ï¼Œè°ƒç”¨processAckæ›´æ–°æµæ§åˆ¶çŠ¶æ€
                            if (data.chunk_type === 'ack') {
                                console.debug(`Received ACK from server: ${data.message_id}, chunk ${data.chunk_index}`);
                                webrtcChunker.processAck(data, 'client'); // ä½¿ç”¨'client'è€Œä¸æ˜¯'server'
                                return; // ACKå¤„ç†å®Œæˆï¼Œä¸éœ€è¦å‘é€å“åº”
                            }
                            
                            // å…¶ä»–åˆ†ç‰‡æ¶ˆæ¯ä½¿ç”¨processChunkå¤„ç†ï¼ˆå®¢æˆ·ç«¯ä½œä¸ºæ¥æ”¶æ–¹ï¼‰
                            const result = webrtcChunker.processChunk(data, 'server');
                            
                            if (result) {
                                if (result.completeMessage) {
                                    // å¤„ç†å®Œæ•´çš„åˆ†ç‰‡æ¶ˆæ¯
                                    this.handleResponse(result.completeMessage);
                                    
                                    // å‘é€å®Œæˆç¡®è®¤
                                    if (result.ackChunk) {
                                        this.dataChannel.send(JSON.stringify(result.ackChunk));
                                    }
                                } else if (result.type === 'chunk' && result.chunk_type === 'ack') {
                                    // å‘é€ACKå“åº”
                                    this.dataChannel.send(JSON.stringify(result));
                                } else if (result.type === 'chunk' && result.chunk_type === 'error') {
                                    // å¤„ç†é”™è¯¯å“åº”
                                    log(`åˆ†ç‰‡ä¼ è¾“é”™è¯¯: ${result.data}`, 'error');
                                } else {
                                    // å‘é€å…¶ä»–ç±»å‹çš„ç¡®è®¤
                                    this.dataChannel.send(JSON.stringify(result));
                                }
                            }
                        } else {
                            // å¤„ç†æ™®é€šæ¶ˆæ¯
                            this.handleResponse(data);
                        }
                        
                    } catch (error) {
                        console.error('Failed to parse data channel response:', error);
                        log(`æ•°æ®é€šé“å“åº”è§£æå¤±è´¥: ${error.message}`, 'error');
                    }
                };
                
                // ç›‘å¬æ•°æ®é€šé“é”™è¯¯
                this.dataChannel.onerror = (error) => {
                    console.error('Data channel error:', error);
                    log(`æ•°æ®é€šé“é”™è¯¯: ${error.toString()}`, 'error');
                    // æ¸…ç†æ‰€æœ‰å¾…å¤„ç†è¯·æ±‚
                    for (const [requestId, { reject }] of this.pendingRequests) {
                        reject(new Error('Data channel error: ' + error.toString()));
                    }
                    this.pendingRequests.clear();
                };
            }
            
            async request(method, endpoint, data = null, headers = {}) {
                return new Promise((resolve, reject) => {
                    if (this.dataChannel.readyState !== 'open') {
                        reject(new Error('Data channel not open'));
                        return;
                    }
                    
                    const requestId = ++this.requestId;
                    const request = {
                        id: requestId,
                        method: method.toUpperCase(),
                        endpoint: endpoint,
                        data: data,
                        headers: headers
                    };
                    
                    // å­˜å‚¨è¯·æ±‚å›è°ƒ
                    this.pendingRequests.set(requestId, { resolve, reject });
                    
                    // å‘é€è¯·æ±‚
                    console.log('Sending API request:', request);
                    log(`å‘é€APIè¯·æ±‚: ${method} ${endpoint} (ID: ${requestId})`, 'info');
                    
                    // æ£€æŸ¥æ•°æ®å¤§å°ï¼Œå†³å®šæ˜¯å¦ä½¿ç”¨åˆ†ç‰‡
                    const requestJson = JSON.stringify(request);
                    const requestSize = new TextEncoder().encode(requestJson).length;
                    
                    if (requestSize > 16000 && webrtcChunker) { // 16KBä»¥ä¸Šä½¿ç”¨åˆ†ç‰‡
                        log(`æ•°æ®è¾ƒå¤§(${Math.round(requestSize/1024)}KB)ï¼Œä½¿ç”¨åˆ†ç‰‡ä¼ è¾“`, 'info');
                        this.sendChunkedRequest(request, resolve, reject);
                    } else {
                        // å°æ•°æ®ç›´æ¥å‘é€
                        this.dataChannel.send(requestJson);
                        
                        // è®¾ç½®è¶…æ—¶
                        setTimeout(() => {
                            if (this.pendingRequests.has(requestId)) {
                                this.pendingRequests.delete(requestId);
                                reject(new Error('Request timeout'));
                            }
                        }, 30000); // 30ç§’è¶…æ—¶
                    }
                });
            }
            
            sendChunkedRequest(request, resolve, reject) {
                try {
                    if (!webrtcChunker) {
                        reject(new Error('WebRTC chunker not available'));
                        return;
                    }
                    
                    // ä½¿ç”¨åˆ†ç‰‡å¤„ç†å™¨åˆ†ç‰‡å¹¶å‘é€
                    const chunks = webrtcChunker.chunkMessage(request, 'client', 2);
                    
                    if (chunks.length === 0) {
                        this.pendingRequests.delete(request.id);
                        reject(new Error('Request queued due to transfer limits'));
                        return;
                    }
                    
                    if (chunks.length === 1) {
                        // å®é™…ä¸Šä¸éœ€è¦åˆ†ç‰‡ï¼Œç›´æ¥å‘é€
                        this.dataChannel.send(JSON.stringify(chunks[0]));
                    } else {
                        // éœ€è¦åˆ†ç‰‡ï¼Œé€ä¸ªå‘é€
                        log(`å‘é€ ${chunks.length} ä¸ªåˆ†ç‰‡`, 'info');
                        this.sendChunks(chunks, request.id);
                    }
                    
                    // è®¾ç½®è¶…æ—¶
                    setTimeout(() => {
                        if (this.pendingRequests.has(request.id)) {
                            this.pendingRequests.delete(request.id);
                            reject(new Error('Chunked request timeout'));
                        }
                    }, 60000); // åˆ†ç‰‡ä¼ è¾“60ç§’è¶…æ—¶
                    
                } catch (error) {
                    if (this.pendingRequests.has(request.id)) {
                        this.pendingRequests.delete(request.id);
                    }
                    reject(error);
                }
            }
            
            async sendChunks(chunks, requestId) {
                for (let i = 0; i < chunks.length; i++) {
                    const chunk = chunks[i];
                    try {
                        this.dataChannel.send(JSON.stringify(chunk));
                        console.log(`Sent chunk ${i+1}/${chunks.length} for request ${requestId}`);
                        
                        // æ·»åŠ å°å»¶è¿Ÿé¿å…å‘é€è¿‡å¿«
                        if (i < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    } catch (error) {
                        log(`å‘é€åˆ†ç‰‡ ${i+1} å¤±è´¥: ${error.message}`, 'error');
                        if (this.pendingRequests.has(requestId)) {
                            const { reject } = this.pendingRequests.get(requestId);
                            this.pendingRequests.delete(requestId);
                            reject(new Error(`Failed to send chunk ${i+1}: ${error.message}`));
                        }
                        return;
                    }
                }
            }
            
            handleResponse(response) {
                console.log('Received API response:', response);
                log(`æ”¶åˆ°APIå“åº”: ID=${response.id}, æˆåŠŸ=${response.success}`, 'info');
                
                const requestId = response.id;
                
                // é¦–å…ˆå°è¯•ç²¾ç¡®åŒ¹é…
                if (this.pendingRequests.has(requestId)) {
                    const { resolve, reject } = this.pendingRequests.get(requestId);
                    this.pendingRequests.delete(requestId);
                    
                    // æ£€æŸ¥å“åº”æ˜¯å¦è¡¨ç¤ºæˆåŠŸ
                    if (response.success) {
                        resolve(response);
                    } else {
                        // å¦‚æœå“åº”åŒ…å«é”™è¯¯ä¿¡æ¯ï¼Œåˆ›å»ºä¸€ä¸ªé”™è¯¯å¯¹è±¡
                        const error = new Error(response.error || response.detail || 'è¯·æ±‚å¤±è´¥');
                        error.response = response;  // ä¿å­˜å®Œæ•´çš„å“åº”ä¿¡æ¯
                        reject(error);
                    }
                    return;
                }
                
                // å¦‚æœç²¾ç¡®åŒ¹é…å¤±è´¥ï¼Œå°è¯•åŸºäºæ—¶é—´æˆ³çš„æ¨¡ç³ŠåŒ¹é…ï¼ˆé€‚ç”¨äºåˆ†ç‰‡è¯·æ±‚ï¼‰
                const responseTime = parseInt(requestId);
                if (!isNaN(responseTime)) {
                    let closestRequestId = null;
                    let minTimeDiff = Infinity;
                    
                    for (const [pendingId] of this.pendingRequests) {
                        const requestTime = parseInt(pendingId);
                        if (!isNaN(requestTime)) {
                            const timeDiff = Math.abs(responseTime - requestTime);
                            if (timeDiff < minTimeDiff && timeDiff < 120000) { // 2åˆ†é’Ÿå†…çš„è¯·æ±‚
                                minTimeDiff = timeDiff;
                                closestRequestId = pendingId;
                            }
                        }
                    }
                    
                    if (closestRequestId && minTimeDiff < 60000) { // 1åˆ†é’Ÿå†…è®¤ä¸ºæ˜¯åŒ¹é…çš„
                        log(`é€šè¿‡æ—¶é—´åŒ¹é…æ‰¾åˆ°è¯·æ±‚: ${closestRequestId} -> ${requestId} (æ—¶å·®: ${minTimeDiff}ms)`, 'info');
                        const { resolve, reject } = this.pendingRequests.get(closestRequestId);
                        this.pendingRequests.delete(closestRequestId);
                        
                        // æ£€æŸ¥å“åº”æ˜¯å¦è¡¨ç¤ºæˆåŠŸ
                        if (response.success) {
                            resolve(response);
                        } else {
                            // å¦‚æœå“åº”åŒ…å«é”™è¯¯ä¿¡æ¯ï¼Œåˆ›å»ºä¸€ä¸ªé”™è¯¯å¯¹è±¡
                            const error = new Error(response.error || response.detail || 'è¯·æ±‚å¤±è´¥');
                            error.response = response;  // ä¿å­˜å®Œæ•´çš„å“åº”ä¿¡æ¯
                            reject(error);
                        }
                        return;
                    }
                }
                
                log(`æœªæ‰¾åˆ°å¯¹åº”çš„è¯·æ±‚ID: ${requestId}`, 'warning');
                log(`å½“å‰å¾…å¤„ç†è¯·æ±‚: [${Array.from(this.pendingRequests.keys()).join(', ')}]`, 'info');
            }
            
            async get(endpoint, headers = {}) {
                return this.request('GET', endpoint, null, headers);
            }
            
            async post(endpoint, data, headers = {}) {
                return this.request('POST', endpoint, data, headers);
            }
        }

        // å¼€å§‹è¿æ¥æµç¨‹
        async function startConnection() {
            const apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                log('è¯·è¾“å…¥API Key', 'error');
                return;
            }

            // å…ˆæ¢æµ‹ç½‘ç»œç¯å¢ƒï¼Œä¼˜å…ˆç›´è¿
            try {
                networkMode = await detectNetworkEnvironment();
            } catch (e) {
                networkMode = 'remote';
            }

            if (networkMode === 'lan') {
                // å±€åŸŸç½‘ç›´è¿æ¨¡å¼ï¼šä¸ä½¿ç”¨WebRTC/ä¿¡ä»¤ï¼Œç›´æ¥HTTPè°ƒç”¨WebAPI
                const internalIp = (document.getElementById('internalIp')?.value || '').trim();
                const baseLanUrl = `http://${internalIp}:5001`;
                apiClient = new HttpAPIClient(baseLanUrl);

                updateStatus('authStatus', 'authStatusText', 'success', 'ç›´è¿å°±ç»ª');
                updateStatus('signalingStatus', 'signalingStatusText', 'success', 'ç›´è¿ï¼Œæ— éœ€ä¿¡ä»¤');
                updateStatus('cameraStatus', 'cameraStatusText', 'info', 'ç›´è¿æ¨¡å¼ï¼šå¯å¯ç”¨æœ¬æœºæ‘„åƒå¤´æˆ–ä¸Šä¼ ');
                showConnectionHint(`
                    <p><strong>âœ… å·²å¯ç”¨å±€åŸŸç½‘ç›´è¿æ¨¡å¼</strong></p>
                    <p>â€¢ å°†ç›´æ¥è°ƒç”¨å†…éƒ¨æœºWebAPIï¼Œä¸ç»è¿‡WebRTC</p>
                    <p>â€¢ æ‚¨å¯ä»¥å¯ç”¨æœ¬æœºæ‘„åƒå¤´è¿›è¡Œæ‹æ‘„ï¼Œæˆ–ç›´æ¥ä¸Šä¼ å¤´åƒå›¾ç‰‡è¿›è¡Œå½•å…¥</p>
                `, 'success');

                log('âœ… å±€åŸŸç½‘ç›´è¿æ¨¡å¼å·²å¯ç”¨', 'success');
                updateProgress(3);

                // åŠ è½½äººå‘˜ç±»å‹ï¼ˆä¸é˜»å¡ï¼‰
                try { await loadProfileTypes(); } catch (e) {}

                // æ˜¾ç¤ºè®¾å¤‡IDè¾“å…¥
                const deviceIdGroup = document.getElementById('deviceIdGroup');
                if (deviceIdGroup) deviceIdGroup.classList.remove('hidden');
                // è®°å½•LANåŸºç¡€URLå¹¶åŠ è½½LANæ‘„åƒå¤´
                lanBaseUrl = baseLanUrl;
                await loadLanManualCameras();
                return; // ä¸å†èµ°è¿œç¨‹WebRTCæµç¨‹
            }

            // å¦‚æœæ­£åœ¨é‡è¿ï¼Œåˆ™å¢åŠ é‡è¿æ¬¡æ•°ï¼Œå¦åˆ™é‡ç½®
            if (!isReconnecting) {
                reconnectAttempts = 0;
                isReconnecting = true;
            } else {
                reconnectAttempts++;
            }

            // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§é‡è¿æ¬¡æ•°
            if (reconnectAttempts > maxReconnectAttempts) {
                log(`å·²è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°(${maxReconnectAttempts})ï¼Œåœæ­¢é‡è¿`, 'error');
                isReconnecting = false;
                showConnectionFailedStatus('è¿æ¥å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°', true);
                hideLoading('connectBtn', 'connectSpinner');
                return;
            }

            // æ˜¾ç¤ºè¿æ¥çŠ¶æ€
            if (reconnectAttempts > 0) {
                log(`ç¬¬ ${reconnectAttempts} æ¬¡é‡è¿å°è¯•...`, 'warning');
                showReconnectStatus('æ­£åœ¨é‡æ–°è¿æ¥...', reconnectAttempts);
            } else {
                log('å¼€å§‹å»ºç«‹è¿æ¥...', 'info');
            }

            // æ¯æ¬¡è¿æ¥éƒ½é‡æ–°ç”Ÿæˆå®¢æˆ·ç«¯ID
            clientID = generateClientId();
            log(`ç”Ÿæˆæ–°çš„å®¢æˆ·ç«¯ID: ${clientID}`, 'info');
            document.getElementById('clientId').value = clientID;
            
            // æ¸…ç†ä¹‹å‰çš„è¿æ¥çŠ¶æ€
            clearAllTimeouts();
            isConnectionEstablished = false;
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            
            if (webrtcChunker) {
                webrtcChunker.stop();
                webrtcChunker = null;
            }
            
            // å…³é—­æ—§çš„WebSocketè¿æ¥
            if (ws) {
                ws.close();
                ws = null;
            }

            // è®¾ç½®æ€»è¿æ¥è¶…æ—¶ï¼ˆ10ç§’ï¼‰
            connectionStartTime = Date.now();
            connectionTimeout = setTimeout(() => {
                if (!isConnectionEstablished) {
                    log('è¿æ¥è¶…æ—¶ï¼Œå¼€å§‹é‡è¿...', 'warning');
                    handleConnectionFailure('è¿æ¥è¶…æ—¶');
                }
            }, 10000);

            showLoading('connectBtn', 'connectSpinner');
            showCancelButton();
            
            // æ˜¾ç¤ºè¿æ¥æç¤º
            if (reconnectAttempts === 0) {
                showConnectionHint(`
                    <p><strong>æ­£åœ¨å»ºç«‹è¿æ¥...</strong></p>
                    <p>â€¢ å¦‚æœé•¿æ—¶é—´æ— å“åº”ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–å†…éƒ¨æœºç¦»çº¿</p>
                    <p>â€¢ ç³»ç»Ÿå°†è‡ªåŠ¨é‡è¯•æœ€å¤š ${maxReconnectAttempts} æ¬¡</p>
                    <p>â€¢ æ‚¨ä¹Ÿå¯ä»¥ç‚¹å‡»"å–æ¶ˆè¿æ¥"åœæ­¢å°è¯•</p>
                `, 'info');
            } else {
                showConnectionHint(`
                    <p><strong>ç¬¬ ${reconnectAttempts} æ¬¡é‡è¿ä¸­...</strong></p>
                    <p>â€¢ ç”±äºç½‘ç»œé—®é¢˜æˆ–STUN/TURNæœåŠ¡å™¨é™åˆ¶ï¼Œè¿æ¥å¯èƒ½éœ€è¦å¤šæ¬¡å°è¯•</p>
                    <p>â€¢ ç³»ç»Ÿå°†ç»§ç»­é‡è¯•ï¼Œè¯·è€å¿ƒç­‰å¾…</p>
                `, 'warning');
            }
            
            try {
                // æ­¥éª¤1: APIè®¤è¯
                await authenticateAPI();
                
                // æ­¥éª¤2: è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨
                await connectSignalingServer();
                
                // è®¾ç½®è§†é¢‘æµè¶…æ—¶ï¼ˆé¢å¤–5ç§’ç­‰å¾…è§†é¢‘æµï¼‰
                videoStreamTimeout = setTimeout(() => {
                    if (!document.querySelector('video') || document.querySelector('video').videoWidth === 0) {
                        log('è§†é¢‘æµè¶…æ—¶ï¼Œå¼€å§‹é‡è¿...', 'warning');
                        handleConnectionFailure('è§†é¢‘æµè·å–è¶…æ—¶');
                    }
                }, 15000);
                
            } catch (error) {
                log(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                handleConnectionFailure(error.message);
            }
        }

        // æ­¥éª¤1: APIè®¤è¯
        async function authenticateAPI() {
            const apiKey = document.getElementById('apiKey').value;
            const authUrl = document.getElementById('authUrl').value;
            
            updateStatus('authStatus', 'authStatusText', 'warning', 'è®¤è¯ä¸­...');
            
            try {
                log('å¼€å§‹API Keyè®¤è¯...', 'info');
                
                const response = await fetch(`${authUrl}/api-auth`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        api_key: apiKey
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    authToken = data.token;
                    updateStatus('authStatus', 'authStatusText', 'success', 'è®¤è¯æˆåŠŸ');
                    log('âœ… API Keyè®¤è¯æˆåŠŸ', 'success');
                    log(`ç§Ÿæˆ·ID: ${data.tenant_id?.substring(0, 10)}...`, 'success');
                    updateProgress(1);
                } else {
                    throw new Error(data.error || 'è®¤è¯å¤±è´¥');
                }
            } catch (error) {
                updateStatus('authStatus', 'authStatusText', 'error', 'è®¤è¯å¤±è´¥');
                throw error;
            }
        }

        // æ­¥éª¤2: è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨
        async function connectSignalingServer() {
            if (!authToken) {
                throw new Error('è¯·å…ˆå®ŒæˆAPI Keyè®¤è¯');
            }

            let signalingUrl = document.getElementById('signalingUrl').value;
            
            updateStatus('signalingStatus', 'signalingStatusText', 'warning', 'è¿æ¥ä¸­...');

            if (!signalingUrl.includes('/ws')) {
                if (signalingUrl.endsWith('/')) {
                    signalingUrl += 'ws';
                } else {
                    signalingUrl += '/ws';
                }
            }

            log('å¼€å§‹ä¿¡ä»¤æœåŠ¡å™¨è¿æ¥...', 'info');

            return new Promise((resolve, reject) => {
                try {
                    ws = new WebSocket(signalingUrl);
                    
                    ws.onopen = function() {
                        log('âœ… WebSocketè¿æ¥å»ºç«‹æˆåŠŸ', 'success');
                        updateStatus('signalingStatus', 'signalingStatusText', 'success', 'è¿æ¥æˆåŠŸ');
                        
                        const registerMsg = {
                            type: 'register',
                            token: authToken,
                            id: clientID
                        };
                        ws.send(JSON.stringify(registerMsg));
                        log('å·²å‘é€å®¢æˆ·ç«¯æ³¨å†Œæ¶ˆæ¯', 'info');
                    };

                    ws.onmessage = function(event) {
                        const message = JSON.parse(event.data);
                        handleSignalingMessage(message, resolve, reject);
                    };

                    ws.onclose = function() {
                        log('âš ï¸ WebSocketè¿æ¥å…³é—­', 'warning');
                        if (document.getElementById('signalingStatusText').textContent !== 'è¿æ¥æˆåŠŸ') {
                            updateStatus('signalingStatus', 'signalingStatusText', 'error', 'è¿æ¥æ–­å¼€');
                        }
                    };

                    ws.onerror = function(error) {
                        log(`âŒ WebSocketè¿æ¥é”™è¯¯`, 'error');
                        updateStatus('signalingStatus', 'signalingStatusText', 'error', 'è¿æ¥å¤±è´¥');
                        reject(new Error('WebSocketè¿æ¥å¤±è´¥'));
                    };

                } catch (error) {
                    log(`âŒ åˆ›å»ºWebSocketè¿æ¥å¤±è´¥: ${error.message}`, 'error');
                    updateStatus('signalingStatus', 'signalingStatusText', 'error', 'è¿æ¥å¤±è´¥');
                    reject(error);
                }
            });
        }

        // å¤„ç†ä¿¡ä»¤æ¶ˆæ¯
        function handleSignalingMessage(message, resolve, reject) {
            log(`æ”¶åˆ°ä¿¡ä»¤æ¶ˆæ¯: ${message.type}`, 'info');

            switch (message.type) {
                case 'registered':
                    log('âœ… å®¢æˆ·ç«¯æ³¨å†ŒæˆåŠŸ', 'success');
                    // è‡ªåŠ¨æŸ¥è¯¢æ‘„åƒå¤´
                    setTimeout(() => {
                        queryCameras(resolve, reject);
                    }, 500);
                    break;
                case 'clients_list':
                    handleClientsList(message.clients, resolve, reject);
                    break;
                case 'answer':
                    handleAnswer(message);
                    break;
                case 'ice-candidate':
                    handleIceCandidate(message);
                    break;
                case 'error':
                    log(`âŒ ä¿¡ä»¤é”™è¯¯: ${message.message}`, 'error');
                    if (reject) reject(new Error(message.message));
                    break;
                default:
                    log(`æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${message.type}`, 'warning');
            }
        }

        // æŸ¥è¯¢æ‘„åƒå¤´
        function queryCameras(resolve, reject) {
            updateStatus('cameraStatus', 'cameraStatusText', 'warning', 'æŸ¥è¯¢ä¸­...');
            log('æ­£åœ¨æŸ¥è¯¢â€œæ‰‹åŠ¨å½•å…¥â€æ‘„åƒå¤´...', 'info');
            
            ws.send(JSON.stringify({
                type: 'query_clients',
                source: clientID
            }));
            
            // å¦‚æœè¶…æ—¶æœªæ‰¾åˆ°æ‘„åƒå¤´ï¼Œè§¦å‘è¿æ¥å¤±è´¥å¤„ç†
            setTimeout(() => {
                if (!selectedClient && !isConnectionEstablished && manualCameras.length === 0) {
                    updateStatus('cameraStatus', 'cameraStatusText', 'error', 'æœªå‘ç°æ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´');
                    handleConnectionFailure('æœªå‘ç°å¯ç”¨çš„æ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´');
                }
            }, 8000);
        }

        // å¤„ç†å®¢æˆ·ç«¯åˆ—è¡¨
        function handleClientsList(clientsList, resolve, reject) {
            log(`å‘ç° ${clientsList.length} ä¸ªå†…éƒ¨æœº`, 'success');

            if (clientsList.length === 0) {
                updateStatus('cameraStatus', 'cameraStatusText', 'error', 'æœªå‘ç°æ‘„åƒå¤´');
                if (reject) reject(new Error('æœªå‘ç°ä»»ä½•å†…éƒ¨æœº'));
                return;
            }

            // æ”¶é›†æ‰€æœ‰æ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´ï¼ˆfunc_type==2ï¼‰
            manualCameras = [];
            for (const client of clientsList) {
                const manual = (client.cameras || []).filter(camera => camera.func_type === 2);
                for (const cam of manual) {
                    manualCameras.push({
                        clientId: client.id,
                        camera: cam
                    });
                }
            }

            if (manualCameras.length === 0) {
                updateStatus('cameraStatus', 'cameraStatusText', 'error', 'æœªå‘ç°æ‰‹åŠ¨å½•å…¥å‹æ‘„åƒå¤´');
                if (reject) reject(new Error('æœªæ‰¾åˆ°func_type==2çš„æ‘„åƒå¤´'));
                return;
            }

            if (manualCameras.length === 1) {
                // åªæœ‰ä¸€ä¸ªæ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´ï¼Œç›´æ¥è¿æ¥
                const found = manualCameras[0];
                selectedClient = found.clientId;
                selectedCamera = found.camera.index;
                selectedCameraType = found.camera.type || 'local';
                deviceId = found.camera.device_id;

                updateStatus('cameraStatus', 'cameraStatusText', 'success', 'æ‘„åƒå¤´å·²è¿æ¥');
                const deviceInfo = document.getElementById('deviceInfo');
                const deviceDetails = document.getElementById('deviceDetails');
                deviceInfo.classList.remove('hidden');
                deviceDetails.innerHTML = `
                    <p><strong>å†…éƒ¨æœº:</strong> ${found.clientId}</p>
                    <p><strong>æ‘„åƒå¤´:</strong> ${found.camera.name}</p>
                    <p><strong>åˆ†è¾¨ç‡:</strong> ${found.camera.resolution} @ ${found.camera.fps}fps</p>
                    <p><strong>ç±»å‹:</strong> ${found.camera.type}</p>
                `;

                const locationInput = document.getElementById('location');
                if (found.camera.location) {
                    locationInput.value = found.camera.location;
                    log(`è®¾ç½®å½•å…¥ä½ç½®ä¸º: ${found.camera.location}`, 'info');
                } else {
                    locationInput.value = found.camera.name;
                    log(`æ‘„åƒå¤´æœªæä¾›ä½ç½®ä¿¡æ¯ï¼Œä½¿ç”¨æ‘„åƒå¤´åç§°ä½œä¸ºå½•å…¥ä½ç½®: ${found.camera.name}`, 'warning');
                }

                log(`âœ… å·²é€‰æ‹©æ‘„åƒå¤´: ${found.camera.name}`, 'success');

                establishWebRTCConnection(found.clientId, found.camera.index)
                    .then(() => {
                        updateProgress(2);
                        if (resolve) resolve();
                    })
                    .catch(error => {
                        log(`WebRTCè¿æ¥å¤±è´¥: ${error.message}`, 'error');
                        handleConnectionFailure(`WebRTCè¿æ¥å¤±è´¥: ${error.message}`);
                        if (reject) reject(error);
                    });
                return;
            }

            // å¤šä¸ªæ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´ï¼šæ˜¾ç¤ºé€‰æ‹©UI
            updateStatus('cameraStatus', 'cameraStatusText', 'info', `å‘ç° ${manualCameras.length} ä¸ªæ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´ï¼Œè¯·é€‰æ‹©`);
            const container = document.getElementById('manualCameraSelection');
            const selectEl = document.getElementById('cameraSelect');
            const btn = document.getElementById('connectCameraBtn');
            if (container && selectEl && btn) {
                container.classList.remove('hidden');
                // å¡«å……é€‰é¡¹
                selectEl.innerHTML = '';
                manualCameras.forEach((entry, idx) => {
                    const cam = entry.camera;
                    const opt = document.createElement('option');
                    opt.value = String(idx);
                    opt.textContent = `${cam.name} (${cam.type}) ${cam.resolution} @ ${cam.fps}fps`;
                    selectEl.appendChild(opt);
                });
                btn.disabled = false;
            }

            // ç¼“å­˜resolve/rejectï¼Œå¾…ç”¨æˆ·é€‰æ‹©åå†è§¦å‘è¿æ¥
            pendingConnectResolve = resolve;
            pendingConnectReject = reject;
        }

        // è¿æ¥æ‰€é€‰â€œæ‰‹åŠ¨å½•å…¥â€æ‘„åƒå¤´
        function connectSelectedCamera() {
            try {
                const selectEl = document.getElementById('cameraSelect');
                if (!selectEl || manualCameras.length === 0) {
                    log('æœªæ‰¾åˆ°å¯ç”¨çš„æ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´', 'error');
                    if (pendingConnectReject) pendingConnectReject(new Error('æœªæ‰¾åˆ°å¯ç”¨çš„æ‰‹åŠ¨å½•å…¥æ‘„åƒå¤´'));
                    return;
                }

                const idx = parseInt(selectEl.value);
                if (isNaN(idx) || idx < 0 || idx >= manualCameras.length) {
                    log('è¯·é€‰æ‹©ä¸€ä¸ªæœ‰æ•ˆçš„æ‘„åƒå¤´', 'warning');
                    return;
                }

                const entry = manualCameras[idx];
                selectedClient = entry.clientId;
                selectedCamera = entry.camera.index;
                selectedCameraType = entry.camera.type || 'local';
                deviceId = entry.camera.device_id;

                // éšè—é€‰æ‹©åŒº
                const container = document.getElementById('manualCameraSelection');
                if (container) container.classList.add('hidden');

                // æ˜¾ç¤ºè®¾å¤‡ä¿¡æ¯
                const deviceInfo = document.getElementById('deviceInfo');
                const deviceDetails = document.getElementById('deviceDetails');
                deviceInfo.classList.remove('hidden');
                deviceDetails.innerHTML = `
                    <p><strong>å†…éƒ¨æœº:</strong> ${entry.clientId}</p>
                    <p><strong>æ‘„åƒå¤´:</strong> ${entry.camera.name}</p>
                    <p><strong>åˆ†è¾¨ç‡:</strong> ${entry.camera.resolution} @ ${entry.camera.fps}fps</p>
                    <p><strong>ç±»å‹:</strong> ${entry.camera.type}</p>
                `;

                const locationInput = document.getElementById('location');
                if (entry.camera.location) {
                    locationInput.value = entry.camera.location;
                } else {
                    locationInput.value = entry.camera.name;
                }

                updateStatus('cameraStatus', 'cameraStatusText', 'success', 'æ‘„åƒå¤´å·²é€‰æ‹©ï¼Œå¼€å§‹è¿æ¥');
                log(`âœ… å·²é€‰æ‹©æ‘„åƒå¤´: ${entry.camera.name}`, 'success');

                establishWebRTCConnection(entry.clientId, entry.camera.index)
                    .then(() => {
                        updateProgress(2);
                        if (pendingConnectResolve) pendingConnectResolve();
                        pendingConnectResolve = null;
                        pendingConnectReject = null;
                    })
                    .catch(error => {
                        log(`WebRTCè¿æ¥å¤±è´¥: ${error.message}`, 'error');
                        handleConnectionFailure(`WebRTCè¿æ¥å¤±è´¥: ${error.message}`);
                        if (pendingConnectReject) pendingConnectReject(error);
                        pendingConnectResolve = null;
                        pendingConnectReject = null;
                    });
            } catch (e) {
                log(`é€‰æ‹©æ‘„åƒå¤´æ—¶å‡ºé”™: ${e.message}`, 'error');
                if (pendingConnectReject) pendingConnectReject(e);
                pendingConnectResolve = null;
                pendingConnectReject = null;
            }
        }
        

        // å»ºç«‹WebRTCè¿æ¥
        async function establishWebRTCConnection(targetClientId, cameraIndex) {
            // ICEå€™é€‰å‘é€çŠ¶æ€è·Ÿè¸ª
            let hasSentValidCandidate = false;
            
            try {
                // åªæœ‰åœ¨å­˜åœ¨æ—§è¿æ¥æ—¶æ‰æ¸…ç†çŠ¶æ€
                if (peerConnection && peerConnection.connectionState !== 'new') {
                    log('æ¸…ç†ä¹‹å‰çš„WebRTCè¿æ¥...', 'info');
                    peerConnection.close();
                    peerConnection = null;
                }
                
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.close();
                    dataChannel = null;
                }
                
                if (webrtcChunker) {
                    webrtcChunker.stop();
                    webrtcChunker = null;
                }

                log(`æ­£åœ¨ä¸ ${targetClientId} å»ºç«‹WebRTCè¿æ¥...`, 'info');

                peerConnection = new RTCPeerConnection(rtcConfig);
                
                // æ·»åŠ è¯¦ç»†çš„ICEçŠ¶æ€ç›‘å¬
                peerConnection.oniceconnectionstatechange = () => {
                    const state = peerConnection.iceConnectionState;
                    log(`ICEè¿æ¥çŠ¶æ€: ${state}`, 'info');
                    
                    switch(state) {
                        case 'checking':
                            log('æ­£åœ¨æ£€æŸ¥ICEè¿æ¥...', 'info');
                            break;
                        case 'connected':
                            log('ICEè¿æ¥å·²å»ºç«‹ï¼', 'success');
                            handleConnectionSuccess();
                            break;
                        case 'completed':
                            log('ICEè¿æ¥å®Œæˆ', 'success');
                            handleConnectionSuccess();
                            break;
                        case 'failed':
                            log('ICEè¿æ¥å¤±è´¥ - å¯èƒ½æ˜¯ç½‘ç»œæˆ–é˜²ç«å¢™é—®é¢˜', 'error');
                            handleConnectionFailure('ICEè¿æ¥å¤±è´¥');
                            break;
                        case 'disconnected':
                            log('ICEè¿æ¥æ–­å¼€', 'warning');
                            if (isConnectionEstablished) {
                                log('è¿æ¥æ„å¤–æ–­å¼€ï¼Œå°è¯•é‡è¿...', 'warning');
                                handleConnectionFailure('è¿æ¥æ„å¤–æ–­å¼€');
                            }
                            break;
                        case 'closed':
                            log('ICEè¿æ¥å·²å…³é—­', 'info');
                            break;
                    }
                };
                
                peerConnection.onicegatheringstatechange = () => {
                    const state = peerConnection.iceGatheringState;
                    log(`ICEæ”¶é›†çŠ¶æ€: ${state}`, 'info');
                };
                
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        log(`ç”ŸæˆICEå€™é€‰: ${event.candidate.candidate.substring(0, 50)}...`, 'info');
                    } else {
                        log('ICEå€™é€‰æ”¶é›†å®Œæˆ', 'info');
                    }
                };
                
                // æ·»åŠ è§†é¢‘æ”¶å‘å™¨
                peerConnection.addTransceiver('video', { direction: 'recvonly' });
                
                // åˆ›å»ºæ•°æ®é€šé“
                dataChannel = peerConnection.createDataChannel('api', {
                    ordered: true
                });
                
                dataChannel.onopen = function() {
                    log('âœ… æ•°æ®é€šé“å·²æ‰“å¼€', 'success');
                    
                    // åˆå§‹åŒ–åˆ†ç‰‡å¤„ç†å™¨
                    webrtcChunker = new WebRTCChunker(8000, 30000, 3);
                    
                    webrtcChunker.onMessageComplete = (clientId, message, messageId) => {
                        log(`âœ… åˆ†ç‰‡æ¶ˆæ¯ç»„è£…å®Œæˆ: ${messageId}`, 'success');
                    };
                    
                    webrtcChunker.onTransferProgress = (clientId, messageId, progress) => {
                        log(`ä¼ è¾“è¿›åº¦: ${Math.round(progress * 100)}% (æ¶ˆæ¯ID: ${messageId})`, 'info');
                    };
                    
                    webrtcChunker.onError = (clientId, error) => {
                        log(`âŒ åˆ†ç‰‡ä¼ è¾“é”™è¯¯: ${error}`, 'error');
                    };
                    
                    // åˆå§‹åŒ–APIå®¢æˆ·ç«¯
                    apiClient = new WebRTCAPIClient(dataChannel);
                    log('WebRTC APIå®¢æˆ·ç«¯å·²åˆå§‹åŒ–', 'success');
                    
                    // å¼‚æ­¥åŠ è½½äººå‘˜ç±»å‹ï¼Œä¸é˜»å¡æ•°æ®é€šé“åˆå§‹åŒ–
                    setTimeout(async () => {
                        await loadProfileTypes();
                    }, 100);
                };
                
                dataChannel.onclose = function() {
                    log('âš ï¸ æ•°æ®é€šé“å·²å…³é—­', 'warning');
                    apiClient = null;
                    webrtcChunker = null;
                };

                // è®¾ç½®è§†é¢‘æµæ¥æ”¶
                peerConnection.ontrack = function(event) {
                    log('âœ… æ”¶åˆ°è§†é¢‘æµ', 'success');
                    
                    let video = document.getElementById('videoContainer').querySelector('video');
                    if (!video) {
                        video = document.createElement('video');
                        video.autoplay = true;
                        video.controls = false;
                        video.muted = true;
                        video.style.width = '100%';
                        video.style.height = '100%';
                        video.style.objectFit = 'contain';
                        document.getElementById('videoContainer').innerHTML = '';
                        document.getElementById('videoContainer').appendChild(video);
                        
                        // ç›‘å¬è§†é¢‘å¼€å§‹æ’­æ”¾
                        video.onloadedmetadata = function() {
                            log(`âœ… è§†é¢‘æµå¼€å§‹æ’­æ”¾ï¼Œåˆ†è¾¨ç‡: ${video.videoWidth}x${video.videoHeight}`, 'success');
                            clearTimeout(videoStreamTimeout); // æ¸…é™¤è§†é¢‘æµè¶…æ—¶
                            handleConnectionSuccess();
                        };
                    }
                    video.srcObject = event.streams[0];
                    
                    // å¯ç”¨æ‹æ‘„æŒ‰é’®
                    document.getElementById('captureBtn').disabled = false;
                    updateProgress(3);
                    updateSubmitButton();
                };

                peerConnection.onicecandidate = function(event) {
                    if (event.candidate) {
                        const candidateStr = event.candidate.candidate;
                        log(`ç”ŸæˆICEå€™é€‰: ${candidateStr.substring(0, 100)}...`, 'info');
                        
                        // åˆ†æå€™é€‰ç±»å‹
                        if (candidateStr.includes('typ host')) {
                            log('â†’ ä¸»æœºå€™é€‰ (ç›´è¿)', 'info');
                        } else if (candidateStr.includes('typ srflx')) {
                            log('â†’ æœåŠ¡å™¨åå°„å€™é€‰ (STUN)', 'info');
                        } else if (candidateStr.includes('typ relay')) {
                            log('â†’ ä¸­ç»§å€™é€‰ (TURN)', 'info');
                        } else if (candidateStr.includes('typ prflx')) {
                            log('â†’ å¯¹ç­‰åå°„å€™é€‰', 'info');
                        }
                        
                        // è¿‡æ»¤mDNSå€™é€‰(.localåœ°å€)ä»¥é¿å…æœåŠ¡å™¨è§£æé—®é¢˜
                        // ä½†æ˜¯å½“æ²¡æœ‰å…¶ä»–å€™é€‰æ—¶ï¼Œå…è®¸TURN/STUNå€™é€‰é€šè¿‡
                        if (candidateStr.includes('.local') && !candidateStr.includes('typ relay') && !candidateStr.includes('typ srflx')) {
                            log(`è·³è¿‡mDNSå€™é€‰: ${candidateStr.substring(0, 50)}...`, 'warning');
                            // ä¸ç›´æ¥returnï¼Œç»§ç»­æ£€æŸ¥æ˜¯å¦æœ‰TURN/STUNå€™é€‰
                            // å¦‚æœè¿™æ˜¯å”¯ä¸€å€™é€‰ä¸”è¶…æ—¶æœªæ”¶åˆ°å…¶ä»–å€™é€‰ï¼Œå°†å‘é€
                            setTimeout(() => {
                                if (!hasSentValidCandidate) {
                                    log('æœªæ‰¾åˆ°æœ‰æ•ˆå€™é€‰ï¼Œå‘é€mDNSå€™é€‰ä½œä¸ºå¤‡é€‰', 'warning');
                                    const iceMessage = {
                                        'type': 'ice-candidate',
                                        'data': {
                                            'candidate': event.candidate.candidate,
                                            'sdpMid': event.candidate.sdpMid,
                                            'sdpMLineIndex': event.candidate.sdpMLineIndex
                                        },
                                        'target': targetClientId,
                                        'source': clientID
                                    };
                                    
                                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                                        websocket.send(JSON.stringify(iceMessage));
                                        log('mDNSå€™é€‰å·²å‘é€', 'info');
                                    }
                                }
                            }, 3000); // 3ç§’åå¦‚æœæ²¡æœ‰å…¶ä»–å€™é€‰å°±å‘é€mDNS
                            return;
                        }
                        
                        // æ ‡è®°å·²å‘é€æœ‰æ•ˆå€™é€‰
                        hasSentValidCandidate = true;
                        
                        const iceMessage = {
                            'type': 'ice-candidate',
                            'data': {
                                'candidate': event.candidate.candidate,
                                'sdpMid': event.candidate.sdpMid,
                                'sdpMLineIndex': event.candidate.sdpMLineIndex
                            },
                            'target': targetClientId,
                            'source': clientID
                        };
                        ws.send(JSON.stringify(iceMessage));
                        log(`âœ… å‘é€ICEå€™é€‰åˆ°æœåŠ¡å™¨: ${candidateStr.substring(0, 50)}...`, 'success');
                    } else {
                        log('ICEå€™é€‰æ”¶é›†å®Œæˆ', 'info');
                    }
                };

                peerConnection.onconnectionstatechange = function() {
                    log(`è¿æ¥çŠ¶æ€å˜åŒ–: ${peerConnection.connectionState}`, 'info');
                };

                // åˆ›å»ºå¹¶å‘é€offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                const offerMessage = {
                    'type': 'offer',
                    'data': {
                        'sdp': peerConnection.localDescription.sdp,
                        'type': peerConnection.localDescription.type
                    },
                    'target': targetClientId,
                    'source': clientID,
                    'camera_index': parseInt(cameraIndex),
                    'camera_type': (selectedCameraType || 'local')
                };
                ws.send(JSON.stringify(offerMessage));
                log('å·²å‘é€offeræ¶ˆæ¯', 'info');

            } catch (error) {
                log(`âŒ å»ºç«‹WebRTCè¿æ¥å¤±è´¥: ${error.message}`, 'error');
                throw error;
            }
        }

        // å¤„ç†answer
        async function handleAnswer(message) {
            try {
                if (peerConnection && message.data) {
                    const answer = new RTCSessionDescription({
                        sdp: message.data.sdp,
                        type: message.data.type
                    });
                    await peerConnection.setRemoteDescription(answer);
                    log('âœ… è¿œç¨‹æè¿°è®¾ç½®æˆåŠŸ', 'success');
                }
            } catch (error) {
                log(`âŒ å¤„ç†answerå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å¤„ç†ICEå€™é€‰
        async function handleIceCandidate(message) {
            try {
                if (peerConnection && message.data) {
                    const candidate = new RTCIceCandidate({
                        candidate: message.data.candidate,
                        sdpMid: message.data.sdpMid,
                        sdpMLineIndex: message.data.sdpMLineIndex
                    });
                    await peerConnection.addIceCandidate(candidate);
                    log('âœ… ICEå€™é€‰æ·»åŠ æˆåŠŸ', 'info');
                }
            } catch (error) {
                log(`âš ï¸ å¤„ç†ICEå€™é€‰å¤±è´¥: ${error.message}`, 'warning');
            }
        }

        // åŠ è½½äººå‘˜ç±»å‹
        async function loadProfileTypes() {
            if (!apiClient) {
                log('APIå®¢æˆ·ç«¯æœªåˆå§‹åŒ–', 'error');
                return;
            }

            if (isProcessing) {
                log('ç³»ç»Ÿæ­£åœ¨å¤„ç†å…¶ä»–è¯·æ±‚ï¼Œè¯·ç¨åé‡è¯•', 'warning');
                return;
            }

            try {
                isProcessing = true;  // è®¾ç½®å¤„ç†çŠ¶æ€
                log('æ­£åœ¨è·å–äººå‘˜ç±»å‹åˆ—è¡¨...', 'info');
                const response = await apiClient.get('/api/profile/types');
                
                if (response.success) {
                    profileTypes = response.types;
                    profileTypesLoaded = true;  // æ ‡è®°åŠ è½½å®Œæˆ
                    log(`âœ… æˆåŠŸè·å– ${profileTypes.length} ä¸ªäººå‘˜ç±»å‹`, 'success');
                    
                    // æ›´æ–°ä¸‹æ‹‰æ¡†
                    const personTypeSelect = document.getElementById('personType');
                    personTypeSelect.innerHTML = '<option value="">è¯·é€‰æ‹©äººå‘˜ç±»å‹</option>';
                    
                    profileTypes.forEach(type => {
                        const option = document.createElement('option');
                        option.value = type.id;
                        option.textContent = `${type.type_name} (${type.description})`;
                        personTypeSelect.appendChild(option);
                    });
                } else {
                    throw new Error(response.error || 'è·å–äººå‘˜ç±»å‹å¤±è´¥');
                }
            } catch (error) {
                log(`âŒ è·å–äººå‘˜ç±»å‹å¤±è´¥: ${error.message}`, 'error');
            } finally {
                isProcessing = false;  // æ¸…é™¤å¤„ç†çŠ¶æ€
            }
        }

        // æ‹æ‘„å›¾åƒ
        async function captureImage() {
            // åœ¨ç›´è¿æ¨¡å¼ä¸‹ï¼Œè‹¥æ— WebRTCè§†é¢‘ï¼Œåˆ™ä»å¿«ç…§æ¥å£æŠ“å–
            if (networkMode === 'lan' && !document.querySelector('video')) {
                return await captureImageLan();
            }

            const video = document.querySelector('video');
            if (!video || video.videoWidth === 0) {
                log('è§†é¢‘æµæœªå‡†å¤‡å°±ç»ª', 'error');
                return;
            }

            // æ£€æŸ¥äººå‘˜ç±»å‹æ˜¯å¦å·²åŠ è½½
            if (!profileTypesLoaded) {
                log('äººå‘˜ç±»å‹æ•°æ®å°šæœªåŠ è½½å®Œæˆï¼Œè¯·ç­‰å¾…', 'warning');
                // å°è¯•é‡æ–°åŠ è½½äººå‘˜ç±»å‹
                if (!isProcessing) {
                    await loadProfileTypes();
                }
                if (!profileTypesLoaded) {
                    log('äººå‘˜ç±»å‹æ•°æ®åŠ è½½å¤±è´¥ï¼Œæ— æ³•è¿›è¡Œäººè„¸å½•å…¥', 'error');
                    return;
                }
            }

            // æ£€æŸ¥æ˜¯å¦æ­£åœ¨å¤„ç†å…¶ä»–è¯·æ±‚
            if (isProcessing) {
                log('ç³»ç»Ÿæ­£åœ¨å¤„ç†å…¶ä»–è¯·æ±‚ï¼Œè¯·ç¨åé‡è¯•', 'warning');
                return;
            }

            try {
                isProcessing = true;  // è®¾ç½®å¤„ç†çŠ¶æ€
                log('å¼€å§‹æ‹æ‘„å›¾åƒ...', 'info');

                // åˆ›å»ºcanvasè¿›è¡Œæˆªå›¾
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // è·å–Base64æ•°æ®
                capturedImageData = canvas.toDataURL('image/jpeg', 0.95);
                
                // æ˜¾ç¤ºæ‹æ‘„çš„å›¾åƒ
                const captureArea = document.getElementById('captureArea');
                captureArea.innerHTML = `
                    <div class="face-detection-overlay" id="faceOverlay">
                        <img class="captured-image" src="${capturedImageData}" alt="æ‹æ‘„çš„å›¾åƒ" />
                    </div>
                    <p style="margin-top: 10px; color: #28a745; font-weight: bold;">
                        åŸå›¾å°ºå¯¸: ${canvas.width} x ${canvas.height}
                    </p>
                    <div id="croppedFacePreview" style="margin-top: 15px; display: none;">
                        <h4 style="color: #495057; margin-bottom: 10px;">ğŸ¯ è£å‰ªåçš„äººè„¸å›¾åƒï¼ˆå°†å…¥åº“å­˜å‚¨ï¼‰:</h4>
                        <img id="croppedFaceImage" class="captured-image" style="max-width: 200px; max-height: 200px;" />
                    </div>
                `;
                
                log(`âœ… å›¾åƒæ‹æ‘„æˆåŠŸï¼å°ºå¯¸: ${canvas.width}x${canvas.height}`, 'success');
                
                // è¿›è¡Œäººè„¸æ£€æµ‹
                await detectFaces();
                
            } catch (error) {
                log(`âŒ æ‹æ‘„å¤±è´¥: ${error.message}`, 'error');
            } finally {
                isProcessing = false;  // æ¸…é™¤å¤„ç†çŠ¶æ€
            }
        }

        // ç›´è¿æ¨¡å¼ï¼šä»å¿«ç…§æ¥å£è¿›è¡Œæ‹æ‘„
        async function captureImageLan() {
            // æ£€æŸ¥äººå‘˜ç±»å‹æ˜¯å¦å·²åŠ è½½
            if (!profileTypesLoaded) {
                log('äººå‘˜ç±»å‹æ•°æ®å°šæœªåŠ è½½å®Œæˆï¼Œè¯·ç­‰å¾…', 'warning');
                if (!isProcessing) {
                    await loadProfileTypes();
                }
                if (!profileTypesLoaded) {
                    log('äººå‘˜ç±»å‹æ•°æ®åŠ è½½å¤±è´¥ï¼Œæ— æ³•è¿›è¡Œäººè„¸å½•å…¥', 'error');
                    return;
                }
            }

            if (!deviceId) {
                log('ç›´è¿æ¨¡å¼ä¸‹éœ€è¦é€‰æ‹©æ‘„åƒå¤´æˆ–å¡«å†™è®¾å¤‡ID', 'error');
                return;
            }

            if (!lanBaseUrl) {
                log('ç›´è¿åŸºç¡€åœ°å€æœªè®¾ç½®', 'error');
                return;
            }

            try {
                isProcessing = true;
                log('å¼€å§‹æŠ“å–å¿«ç…§...', 'info');

                const resp = await fetch(`${lanBaseUrl}/api/camera/snapshot?device_id=${deviceId}&ts=${Date.now()}`, { cache: 'no-store' });
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const blob = await resp.blob();

                const dataUrl = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(new Error('è¯»å–å¿«ç…§å¤±è´¥'));
                    reader.readAsDataURL(blob);
                });

                const imgInfo = await new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
                    img.onerror = () => reject(new Error('å¿«ç…§åŠ è½½å¤±è´¥'));
                    img.src = dataUrl;
                });

                capturedImageData = dataUrl;
                const captureArea = document.getElementById('captureArea');
                captureArea.innerHTML = `
                    <div class="face-detection-overlay" id="faceOverlay">
                        <img class="captured-image" src="${capturedImageData}" alt="æ‹æ‘„çš„å›¾åƒ" />
                    </div>
                    <p style="margin-top: 10px; color: #28a745; font-weight: bold;">
                        åŸå›¾å°ºå¯¸: ${imgInfo.width} x ${imgInfo.height}
                    </p>
                    <div id="croppedFacePreview" style="margin-top: 15px; display: none;">
                        <h4 style="color: #495057; margin-bottom: 10px;">ğŸ¯ è£å‰ªåçš„äººè„¸å›¾åƒï¼ˆå°†å…¥åº“å­˜å‚¨ï¼‰:</h4>
                        <img id="croppedFaceImage" class="captured-image" style="max-width: 200px; max-height: 200px;" />
                    </div>
                `;

                log(`âœ… å¿«ç…§è·å–æˆåŠŸï¼å°ºå¯¸: ${imgInfo.width}x${imgInfo.height}`, 'success');
                await detectFaces();
            } catch (e) {
                log(`âŒ å¿«ç…§æ‹æ‘„å¤±è´¥: ${e.message}`, 'error');
            } finally {
                isProcessing = false;
            }
        }

        // äººè„¸æ£€æµ‹
        async function detectFaces() {
            if (!apiClient || !capturedImageData) {
                log('APIå®¢æˆ·ç«¯æœªåˆå§‹åŒ–æˆ–æ— æ‹æ‘„å›¾åƒ', 'error');
                return;
            }

            try {
                // æ³¨æ„ï¼šè¿™ä¸ªå‡½æ•°ç”±captureImageè°ƒç”¨ï¼ŒisProcessingçŠ¶æ€å·²ç»åœ¨captureImageä¸­ç®¡ç†
                log('å¼€å§‹äººè„¸æ£€æµ‹...', 'info');
                
                const response = await apiClient.post('/api/face/capture', {
                    image: capturedImageData
                });
                
                if (response.success) {
                    detectedFaces = response.faces || [];
                    log(`âœ… äººè„¸æ£€æµ‹å®Œæˆï¼Œæ£€æµ‹åˆ° ${detectedFaces.length} å¼ äººè„¸`, 'success');
                    
                    // æ˜¾ç¤ºæ£€æµ‹ç»“æœ
                    displayFaceDetectionResult();
                    
                    if (detectedFaces.length === 1) {
                        // åªæœ‰ä¸€å¼ äººè„¸ï¼Œè£å‰ªäººè„¸åŒºåŸŸ
                        log('âœ… äººè„¸æ£€æµ‹æˆåŠŸï¼Œæ­£åœ¨è£å‰ªäººè„¸åŒºåŸŸ...', 'success');
                        const faceBox = detectedFaces[0].bbox;
                        
                        try {
                            croppedFaceImageData = await cropFaceFromImage(capturedImageData, faceBox);
                            
                            // æ˜¾ç¤ºè£å‰ªåçš„äººè„¸é¢„è§ˆ
                            const croppedFacePreview = document.getElementById('croppedFacePreview');
                            const croppedFaceImage = document.getElementById('croppedFaceImage');
                            if (croppedFacePreview && croppedFaceImage) {
                                croppedFaceImage.src = croppedFaceImageData;
                                croppedFacePreview.style.display = 'block';
                            }
                            
                            log('âœ… äººè„¸åŒºåŸŸè£å‰ªå®Œæˆï¼Œå¯ä»¥å¼€å§‹äººå‘˜ä¿¡æ¯å½•å…¥', 'success');
                            updateProgress(4);
                            updateSubmitButton();
                        } catch (error) {
                            log(`âŒ äººè„¸è£å‰ªå¤±è´¥: ${error.message}`, 'error');
                            croppedFaceImageData = null;
                            
                            // éšè—è£å‰ªé¢„è§ˆ
                            const croppedFacePreview = document.getElementById('croppedFacePreview');
                            if (croppedFacePreview) {
                                croppedFacePreview.style.display = 'none';
                            }
                            
                            updateSubmitButton();
                        }
                    } else if (detectedFaces.length === 0) {
                        log('âš ï¸ æœªæ£€æµ‹åˆ°äººè„¸ï¼Œè¯·é‡æ–°æ‹æ‘„', 'warning');
                        croppedFaceImageData = null;
                        updateSubmitButton();
                    } else {
                        log(`âš ï¸ æ£€æµ‹åˆ°å¤šå¼ äººè„¸ (${detectedFaces.length} å¼ )ï¼Œè¯·ç¡®ä¿å›¾ç‰‡ä¸­åªæœ‰ä¸€å¼ äººè„¸`, 'warning');
                        croppedFaceImageData = null;
                        updateSubmitButton();
                    }
                    
                } else {
                    throw new Error(response.error || 'äººè„¸æ£€æµ‹å¤±è´¥');
                }
                
            } catch (error) {
                log(`âŒ äººè„¸æ£€æµ‹å¤±è´¥: ${error.message}`, 'error');
                throw error;  // å‘ä¸ŠæŠ›å‡ºé”™è¯¯ï¼Œç”±captureImageå¤„ç†
            }
        }

        // æ˜¾ç¤ºäººè„¸æ£€æµ‹ç»“æœ
        function displayFaceDetectionResult() {
            const overlay = document.getElementById('faceOverlay');
            const img = overlay.querySelector('img');
            
            if (!img) return;
            
            // ç­‰å¾…å›¾åƒå®Œå…¨åŠ è½½
            const waitForImageLoad = () => {
                return new Promise((resolve) => {
                    if (img.complete && img.naturalWidth > 0) {
                        resolve();
                    } else {
                        img.onload = () => resolve();
                    }
                });
            };
            
            waitForImageLoad().then(() => {
                // æ¸…é™¤ä¹‹å‰çš„æ£€æµ‹æ¡†
                const existingBoxes = overlay.querySelectorAll('.face-box');
                existingBoxes.forEach(box => box.remove());
                
                // ä¸ºæ¯ä¸ªæ£€æµ‹åˆ°çš„äººè„¸æ·»åŠ æ£€æµ‹æ¡†
                detectedFaces.forEach((face, index) => {
                    const [x, y, w, h] = face.bbox;
                    const confidence = face.confidence;
                    
                    // è·å–å›¾åƒçš„å®é™…å°ºå¯¸ä¿¡æ¯
                    const imgNaturalWidth = img.naturalWidth;
                    const imgNaturalHeight = img.naturalHeight;
                    const imgDisplayWidth = img.offsetWidth;
                    const imgDisplayHeight = img.offsetHeight;
                    
                    console.log(`å›¾åƒå°ºå¯¸ä¿¡æ¯: è‡ªç„¶å°ºå¯¸=${imgNaturalWidth}x${imgNaturalHeight}, æ˜¾ç¤ºå°ºå¯¸=${imgDisplayWidth}x${imgDisplayHeight}`);
                    
                    // ä½¿ç”¨è‡ªç„¶å°ºå¯¸è®¡ç®—è£å‰ªåŒºåŸŸï¼ˆè¿™ä¸å®é™…è£å‰ªæ—¶ä½¿ç”¨çš„å°ºå¯¸ä¸€è‡´ï¼‰
                    const { cropX, cropY, cropW, cropH } = calculateCropRegion(face.bbox, imgNaturalWidth, imgNaturalHeight);
                    
                    // è®¡ç®—æ˜¾ç¤ºæ¯”ä¾‹ï¼Œè€ƒè™‘ object-fit: contain çš„å½±å“
                    const naturalRatio = imgNaturalWidth / imgNaturalHeight;
                    const displayRatio = imgDisplayWidth / imgDisplayHeight;
                    
                    let actualDisplayWidth, actualDisplayHeight, offsetX, offsetY;
                    
                    if (naturalRatio > displayRatio) {
                        // å›¾åƒå®½åº¦å¡«æ»¡å®¹å™¨ï¼Œé«˜åº¦æœ‰ç©ºä½™
                        actualDisplayWidth = imgDisplayWidth;
                        actualDisplayHeight = imgDisplayWidth / naturalRatio;
                        offsetX = 0;
                        offsetY = (imgDisplayHeight - actualDisplayHeight) / 2;
                    } else {
                        // å›¾åƒé«˜åº¦å¡«æ»¡å®¹å™¨ï¼Œå®½åº¦æœ‰ç©ºä½™
                        actualDisplayWidth = imgDisplayHeight * naturalRatio;
                        actualDisplayHeight = imgDisplayHeight;
                        offsetX = (imgDisplayWidth - actualDisplayWidth) / 2;
                        offsetY = 0;
                    }
                    
                    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
                    const scaleX = actualDisplayWidth / imgNaturalWidth;
                    const scaleY = actualDisplayHeight / imgNaturalHeight;
                    
                    console.log(`ç¼©æ”¾ä¿¡æ¯: scaleX=${scaleX}, scaleY=${scaleY}, offsetX=${offsetX}, offsetY=${offsetY}`);
                    
                    const faceBox = document.createElement('div');
                    faceBox.className = 'face-box';
                    
                    // ä½¿ç”¨ä¿®æ­£åçš„åæ ‡å’Œå°ºå¯¸
                    faceBox.style.left = (offsetX + cropX * scaleX) + 'px';
                    faceBox.style.top = (offsetY + cropY * scaleY) + 'px';
                    faceBox.style.width = (cropW * scaleX) + 'px';
                    faceBox.style.height = (cropH * scaleY) + 'px';
                    
                    const confidenceLabel = document.createElement('div');
                    confidenceLabel.className = 'face-confidence';
                    confidenceLabel.textContent = `${(confidence * 100).toFixed(1)}%`;
                    
                    faceBox.appendChild(confidenceLabel);
                    overlay.appendChild(faceBox);
                    
                    log(`äººè„¸ ${index + 1}: åŸå§‹(${x},${y},${w},${h}) -> è£å‰ª(${cropX},${cropY},${cropW},${cropH}) -> æ˜¾ç¤º(${offsetX + cropX * scaleX},${offsetY + cropY * scaleY}), ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(1)}%`, 'info');
                });
            });
        }

        // æäº¤äººå‘˜æ³¨å†Œ
        async function submitRegistration() {
            // éªŒè¯è¡¨å•
            if (!validateForm()) {
                log('è¯·æ£€æŸ¥å¹¶ä¿®æ­£è¡¨å•ä¸­çš„é”™è¯¯', 'error');
                return;
            }

            // æ£€æŸ¥æ˜¯å¦æ­£åœ¨å¤„ç†å…¶ä»–è¯·æ±‚
            if (isProcessing) {
                log('ç³»ç»Ÿæ­£åœ¨å¤„ç†å…¶ä»–è¯·æ±‚ï¼Œè¯·ç¨åé‡è¯•', 'warning');
                return;
            }

            // è·å–è¡¨å•æ•°æ®
            const personName = document.getElementById('personName').value.trim();
            const personType = document.getElementById('personType').value;
            const roomId = document.getElementById('roomId').value.trim();
            const phoneNumber = document.getElementById('phoneNumber').value.trim();
            const idCardNumber = document.getElementById('idCardNumber').value.trim();
            const location = document.getElementById('location').value.trim() || 'äººè„¸å½•å…¥ç³»ç»Ÿ';

            // ç›´è¿æ¨¡å¼å…è®¸é€šè¿‡è¾“å…¥æ¡†æä¾›è®¾å¤‡ID
            if (!deviceId) {
                if (networkMode === 'lan') {
                    const manualDeviceId = (document.getElementById('deviceIdInput')?.value || '').trim();
                    if (!manualDeviceId) {
                        log('ç›´è¿æ¨¡å¼ä¸‹è¯·å¡«å†™è®¾å¤‡ID', 'error');
                        const errDiv = document.getElementById('deviceIdError');
                        if (errDiv) errDiv.textContent = 'è¯·å¡«å†™è®¾å¤‡ID';
                        return;
                    }
                    deviceId = manualDeviceId;
                } else {
                    log('è®¾å¤‡IDç¼ºå¤±ï¼Œè¯·é‡æ–°è¿æ¥æ‘„åƒå¤´', 'error');
                    return;
                }
            }

            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="loading-spinner"></span> æäº¤ä¸­...';

            try {
                isProcessing = true;  // è®¾ç½®å¤„ç†çŠ¶æ€
                log('å¼€å§‹æäº¤äººå‘˜æ³¨å†Œä¿¡æ¯...', 'info');

                const registrationData = {
                    image: croppedFaceImageData,  // ä½¿ç”¨è£å‰ªåçš„äººè„¸å›¾åƒç”¨äºè¯†åˆ«
                    original_image: capturedImageData,  // åŸå§‹å›¾åƒç”¨äºæŠ“æ‹è®°å½•
                    face_bbox: detectedFaces[0].bbox,  // äººè„¸æ£€æµ‹æ¡†ä¿¡æ¯
                    name: personName,
                    type_id: personType,
                    room_id: roomId || null,
                    phone_number: phoneNumber || null,
                    id_card_number: idCardNumber || null,
                    location: location,
                    device_id: deviceId.toString(),
                    device_type: 0  // 0è¡¨ç¤ºå½•å…¥è®¾å¤‡ï¼Œç”¨äºç”Ÿæˆå­˜å‚¨è·¯å¾„
                };

                const response = await apiClient.post('/api/face/register', registrationData);

                if (response.success) {
                    log('âœ… äººè„¸ä¿¡æ¯å…¥åº“æˆåŠŸ', 'success');
                    
                    // æ˜¾ç¤ºæˆåŠŸç»“æœ
                    const resultDiv = document.getElementById('registrationResult');
                    const selectedTypeInfo = profileTypes.find(t => t.id == personType);
                    
                    resultDiv.innerHTML = `
                        <div class="alert alert-success">
                            <h4>âœ… å…¥åº“æˆåŠŸï¼</h4>
                            <p><strong>å§“å:</strong> ${personName}</p>
                            <p><strong>äººå‘˜ç±»å‹:</strong> ${response.type_name || (selectedTypeInfo ? selectedTypeInfo.type_name : 'æœªçŸ¥')}</p>
                            <p><strong>å­˜å‚¨ä½ç½®:</strong> ${response.storage_location || 'æœªçŸ¥'}</p>
                            <p><strong>Profile ID:</strong> ${response.profile_id}</p>
                            <p><strong>${response.is_temporary ? 'TemporaryFace' : 'Face'} ID:</strong> ${response.face_id}</p>
                            ${roomId ? `<p><strong>æˆ¿é—´å·:</strong> ${roomId}</p>` : ''}
                            ${phoneNumber ? `<p><strong>æ‰‹æœºå·:</strong> ${phoneNumber}</p>` : ''}
                        </div>
                    `;

                    updateProgress(5);
                    
                    const storageType = response.is_temporary ? 'ä¸´æ—¶' : 'æ­£å¼';
                    log(`äººå‘˜ "${personName}" å·²æˆåŠŸå½•å…¥${storageType}äººè„¸åº“`, 'success');
                    log(`å­˜å‚¨ä½ç½®: ${response.storage_location}`, 'success');
                    
                } else {
                    throw new Error(response.error || 'å…¥åº“å¤±è´¥');
                }

            } catch (error) {
                log(`âŒ äººå‘˜æ³¨å†Œå¤±è´¥: ${error.message}`, 'error');
                
                const resultDiv = document.getElementById('registrationResult');
                
                // åˆ¤æ–­æ˜¯å¦ä¸ºé‡å¤äººè„¸çš„é”™è¯¯
                const isDuplicateFace = error.message.includes('äººè„¸ä¿¡æ¯å·²å­˜åœ¨') || 
                                       error.message.includes('å·²å­˜åœ¨äºæ­£å¼åº“') ||
                                       error.message.includes('æ— æ³•é‡å¤å½•å…¥') ||
                                       error.message.includes('ç›¸ä¼¼åº¦ä¸º');
                
                let alertContent = '';
                if (isDuplicateFace) {
                    // é‡å¤äººè„¸çš„ç‰¹æ®Šå¤„ç†
                    alertContent = `
                        <div class="alert alert-warning" style="border-left: 4px solid #ffc107;">
                            <h4>âš ï¸ é‡å¤äººè„¸æ£€æµ‹</h4>
                            <div style="margin: 15px 0; padding: 12px; background-color: #fff8e1; border-radius: 5px;">
                                <strong>è¯¦ç»†è¯´æ˜:</strong> ${error.message}
                            </div>
                            <div style="margin-top: 15px;">
                                <p style="margin: 5px 0;"><strong>ğŸ’¡ å¯èƒ½çš„è§£å†³æ–¹æ¡ˆ:</strong></p>
                                <ul style="margin: 5px 0 10px 20px; line-height: 1.6;">
                                    <li>å¦‚æœç¡®è®¤æ˜¯æ–°äººå‘˜ï¼Œè¯·ä»”ç»†æ£€æŸ¥æ‹æ‘„çš„äººè„¸å›¾åƒæ˜¯å¦æ¸…æ™°</li>
                                    <li>å°è¯•é‡æ–°æ‹æ‘„ï¼Œç¡®ä¿å…‰çº¿å……è¶³ã€è§’åº¦åˆé€‚</li>
                                    <li>å¦‚æœç¡®å®æ˜¯é‡å¤å½•å…¥ï¼Œè¯·å¿½ç•¥æ­¤æ¬¡æ“ä½œ</li>
                                    <li>å¦‚æœ‰ç–‘é—®ï¼Œè¯·è”ç³»ç³»ç»Ÿç®¡ç†å‘˜ç¡®è®¤äººå‘˜èº«ä»½</li>
                                </ul>
                            </div>
                        </div>
                    `;
                } else {
                    // å…¶ä»–ç±»å‹é”™è¯¯çš„å¤„ç†
                    alertContent = `
                        <div class="alert alert-danger">
                            <h4>âŒ å…¥åº“å¤±è´¥</h4>
                            <div style="margin: 15px 0; padding: 12px; background-color: #f8d7da; border-radius: 5px;">
                                <strong>é”™è¯¯è¯¦æƒ…:</strong> ${error.message}
                            </div>
                            <div style="margin-top: 15px;">
                                <p style="margin: 5px 0;"><strong>ğŸ”§ å»ºè®®æ£€æŸ¥:</strong></p>
                                <ul style="margin: 5px 0 10px 20px; line-height: 1.6;">
                                    <li>ç¡®è®¤æ‰€æœ‰å¿…å¡«ä¿¡æ¯å·²æ­£ç¡®å¡«å†™</li>
                                    <li>æ£€æŸ¥äººè„¸å›¾åƒæ˜¯å¦æ¸…æ™°å®Œæ•´</li>
                                    <li>ç¡®è®¤ç½‘ç»œè¿æ¥æ­£å¸¸</li>
                                    <li>å¦‚é—®é¢˜æŒç»­ï¼Œè¯·è”ç³»ç³»ç»Ÿç®¡ç†å‘˜</li>
                                </ul>
                            </div>
                        </div>
                    `;
                }
                
                resultDiv.innerHTML = alertContent;
            } finally {
                isProcessing = false;  // æ¸…é™¤å¤„ç†çŠ¶æ€
                submitBtn.disabled = false;
                submitBtn.innerHTML = 'ğŸ’¾ æäº¤å…¥åº“';
            }
        }

        // é‡ç½®è¡¨å•
        function resetForm() {
            // æ£€æŸ¥æ˜¯å¦æ­£åœ¨å¤„ç†å…¶ä»–è¯·æ±‚
            if (isProcessing) {
                log('ç³»ç»Ÿæ­£åœ¨å¤„ç†å…¶ä»–è¯·æ±‚ï¼Œæ— æ³•é‡ç½®', 'warning');
                return;
            }

            // æ¸…ç©ºè¡¨å•
            document.getElementById('personName').value = '';
            document.getElementById('personType').value = '';
            document.getElementById('roomId').value = '';
            document.getElementById('phoneNumber').value = '';
            document.getElementById('idCardNumber').value = '';
            document.getElementById('location').value = 'äººè„¸å½•å…¥ç³»ç»Ÿ';
            
            // æ¸…é™¤æ‰€æœ‰éªŒè¯çŠ¶æ€
            const formFields = ['personName', 'personType', 'phoneNumber', 'idCardNumber', 'roomId', 'location'];
            formFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                const errorDiv = document.getElementById(fieldId + 'Error');
                if (field && errorDiv) {
                    field.classList.remove('error', 'valid');
                    errorDiv.textContent = '';
                }
            });
            
            // éšè—éªŒè¯æ¶ˆæ¯
            document.getElementById('formValidationMessage').style.display = 'none';
            document.getElementById('registrationResult').innerHTML = '';
            
            // æ¸…ç©ºæ‹æ‘„ç»“æœ
            document.getElementById('captureArea').innerHTML = '<p id="captureHint">è¯·ç‚¹å‡»æ‹æ‘„æˆ–ä¸Šä¼ æŒ‰é’®é‡æ–°é‡‡é›†</p>';
            
            capturedImageData = null;
            croppedFaceImageData = null;  // æ¸…é™¤è£å‰ªåçš„äººè„¸å›¾åƒ
            detectedFaces = [];
            // æ¸…ç†è®¾å¤‡IDè¾“å…¥
            const devInput = document.getElementById('deviceIdInput');
            const devErr = document.getElementById('deviceIdError');
            if (devInput) devInput.value = '';
            if (devErr) devErr.textContent = '';
            
            updateProgress(3);
            updateSubmitButton();
            log('è¡¨å•å·²é‡ç½®ï¼Œè¯·é‡æ–°æ‹æ‘„', 'info');
        }

        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        window.addEventListener('beforeunload', function() {
            // åœæ­¢é‡è¿
            isReconnecting = false;
            clearAllTimeouts();
            
            if (webrtcChunker) {
                webrtcChunker.stop();
            }
            if (ws) {
                ws.close();
            }
            if (peerConnection) {
                peerConnection.close();
            }
            // åœæ­¢æœ¬æœºæ‘„åƒå¤´æµ
            try {
                if (localStream) {
                    localStream.getTracks().forEach(t => t.stop());
                }
            } catch (e) {}
            // åœæ­¢ç›´è¿é¢„è§ˆè½®è¯¢
            try {
                if (lanPreviewTimer) {
                    clearInterval(lanPreviewTimer);
                    lanPreviewTimer = null;
                }
            } catch (e) {}
        });
    </script>
  </body>
</html>
